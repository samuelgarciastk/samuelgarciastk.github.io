---
title: 启发式算法概述
categories:
  - Algorithm
  - Heuristic Algorithm
tags:
  - Algorithm
  - Heuristic Algorithm
mathjax: true
abbrlink: f121a420
---

# 概述

启发式算法（Heuristic Algorithm）是相对于最优化算法提出的。它有不同的定义：

- 其中一种是，一个基于直观或经验构造的算法，在可接受的花费（指计算时间和空间）下给出待解决组合优化问题每一个实例的一个可行解，该可行解与最优解的偏离程度一般不能被预计。
- 另一种是，启发式算法是一种技术，这种技术使得在可接受的计算成本内去搜寻最好的解，但不一定能保证所得的可行解和最优解，甚至在多数情况下，无法阐述所得解同最优解的近似程度。

启发式算法是一种近似算法，它更像是一种算法框架，定义了算法的流程步骤，并没有成型的理论体系。

有一类的通用启发式策略称为元启发式算法（Metaheuristic），通常使用乱数搜寻技巧。他们可以应用在非常广泛的问题上，但不能保证效率。近年来随着智能计算领域的发展，出现了一类被称为超启发式算法（Hyper-Heuristic Algorithm）的新算法类型。

以下表格是对启发式算法的分类：

||传统启发式算法|元启发式算法|超启发式算法|
|:-|:-|:-|:-|
|搜索空间|由实例解构成|由实例解构成|由启发式算法构成|
|问题的领域知识|需要|需要|不需要（或很少需要）|
|典型类别|局部搜索<br>爬山法<br>贪心法|蚁群算法<br>粒子群算法<br>模拟退火算法<br>遗传算法<br>禁忌搜索<br>进化规划<br>进化策略<br>变邻域搜索<br>人工神经网络|基于随机选择的超启发式算法<br>基于贪心策略的超启发式算法<br>基于元启发式算法的超启发式算法<br>基于学习的超启发式算法|

<!-- more -->

下面对一些元启发式算法进行介绍。

# 蚁群算法（Ant Colony Optimization, ACO）

# 粒子群算法 （Particle Swarm Optimization, PSO）

粒子群算法，也称粒子群优化算法或鸟群觅食算法，来源于对一个简化社会模型的模拟。PSO算法属于进化算法的一种，和模拟退火算法相似，它也是从随机解出发，通过迭代寻找最优解，它也是通过适应度来评价解的品质，但它比遗传算法规则更为简单，它没有遗传算法的“交叉”（Crossover）和“变异”（Mutation）操作，它通过追随当前搜索到的最优值来寻找全局最优。这种算法以其实现容易、精度高、收敛快等优点引起了学术界的重视，并且在解决实际问题中展示了其优越性。粒子群算法是一种并行算法。

## 算法原理

设想这样一个场景：一群鸟在随机搜索食物。在这个区域里只有一块食物。所有的鸟都不知道食物在那里。但是他们知道当前的位置离食物还有多远。那么找到食物的最优策略是什么呢。最简单有效的就是搜寻目前离食物最近的鸟的周围区域。

PSO从这种模型中得到启示并用于解决优化问题。PSO中，每个优化问题的解都是搜索空间中的一只鸟。我们称之为“粒子”。所有的粒子都有一个由被优化的函数决定的适应值（fitness value），每个粒子还有一个速度决定他们飞翔的方向和距离。然后粒子们就追随当前的最优粒子在解空间中搜索。

PSO算法是基于群体的，根据对环境的适应度将群体中的个体移动到好的区域。然而它不对个体使用演化算子，而是将每个个体看作是$D$维搜索空间中的一个没有体积的微粒（点），在搜索空间中以一定的速度飞行，这个速度根据它本身的飞行经验和同伴的飞行经验来动态调整。第$i$个微粒表示为$X_i = (x_{i1}, x_{i2}, ..., x_{iD})$，它经历过的最好位置（有最好的适应值）记为$P_i = (p_{i1}, p_{i2}, ..., p_{iD})$，也称为$pBest$。在群体所有微粒经历过的最好位置的索引号用符号$g$表示，即$P_g$，也称为$gBest$。微粒i的速度用$V_i = (v_{i1}, v_{i2}, ..., v_{iD})$表示。对每一代，它的第$d$维$(1 ≤ d ≤ D)$根据如下方程进行变化：

$$v_{id} = w \cdot v_{id} + c_1 \cdot rand() \cdot (p_{id} - x_{id}) + c_2 \cdot rand() \cdot (p_{gd} - x_{id})$$

$$x_{id} = x_{id} + v_{id}$$

其中w为惯性权重（Inertia Weight），c1和c2为加速常数（Acceleration Constants），rand()为在[0,1]范围里变化的随机值。此外，微粒的速度$V_i$被一个最大速度$V_{max}$所限制。如果当前对微粒的加速导致它的在某维的速度$v_{id}$超过该维的最大速度$v_{max,d}$，则该维的速度被限制为该维最大速度$v_{max,d}$。

## 算法流程

1. 初始化一群微粒（群体规模为m），包括随机的位置和速度；
2. 评价每个微粒的适应度；
3. 对每个微粒，将它的适应值和它经历过的最好位置pBest的作比较，如果较好，则将其作为当前的最好位置pBest；
4. 对每个微粒，将它的适应值和全局所经历最好位置gBest的作比较，如果较好，则重新设置gBest的索引号；
5. 根据上述方程变化微粒的速度和位置；
6. 如未达到结束条件（通常为足够好的适应值或达到一个预设最大代数$G_{max}$），回到2。

# 模拟退火（Simulated Annealing, SA）

# 遗传算法（Genetic Algorithm, GA）

# 禁忌搜索（Tabu Search, TS）

# 总结

启发式算法感觉什么都能做，但是什么都做不好。

最后引用
