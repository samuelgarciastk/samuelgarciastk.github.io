#+STARTUP: fold
#+OPTIONS: author:nil
#+HUGO_SECTION: post
#+HUGO_BASE_DIR: ../
#+HUGO_AUTO_SET_LASTMOD: t

* Programming :@programming:
** Java :@java:
*** DONE 通过 Java API 实现 Kafka Consumer 从最开始消费 :kafka:java:
CLOSED: [2018-03-06 Tue 22:07]
:PROPERTIES:
:EXPORT_FILE_NAME: kafka-consume-data-from-the-beginning
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :toc false
:END:
之前写项目的时候需要通过 Java API 实现 Consumer 每次都从最开始消费，也就是将 Kafka topic 下所有 partition 的 offset 重置到最初位置。

<!--more-->

这个功能类似 shell 下的命令：

#+BEGIN_SRC sh
./kafka-console-consumer.sh --bootstrap-server serverip:9092 --topic topic --from-beginning
#+END_SRC

Kafka 的 JavaDoc 中提到可以使用 =seekToBeginning(Collection<TopicPartition>)= 方法来实现 =--from-beginning= 的功能，但是文档中没有详细说明如何使用，只是提及这个方法“evaluates lazily”， 只有在调用 =poll(long)= 或 =position(TopicPartition)= 的时候才重置 offset 到开头。
所以直接在 =subscribe(Pattern pattern)= 后调用是不起作用的。

正确的方法应该是在 Partition 分配后的回掉函数中重置 offset，具体代码如下：

#+BEGIN_SRC java
consumer.subscribe(Collections.singletonList(topic), new ConsumerRebalanceListener() {
        @Override
        public void onPartitionsRevoked(Collection<TopicPartition> partitions) {
        }

        @Override
        public void onPartitionsAssigned(Collection<TopicPartition> partitions) {
            consumer.seekToBeginning(partitions);
        }
    });
#+END_SRC
*** DONE JDK 10 新特性 :java:
CLOSED: [2018-03-24 Sat 19:27]
:PROPERTIES:
:EXPORT_FILE_NAME: jdk-10-new-features
:END:
前几天 JDK 10 正式发布了，距离上一次 JDK 9 发布才没几周时间，但是 JDK 10 还是更新了许多新特性。
下面介绍一下几个比较重要的新特性。

<!--more-->

**** 局部变量类型推断
对于开发者来说，这是 JDK 10 唯一的真正特性。
它向 Java 中引入在其他语言中很常见的 =var= ，比如 JavaScript。
只要编译器可以推断此种类型，你不再需要专门声明一个局部变量的类型。
一个简单的例子是：

#+BEGIN_SRC java
var x = new ArrayList();
#+END_SRC

首先，Java 的 =var= 和 JavaScript 的完全不同，不要这样去类比。
Java 的 =var= 是用于局部类型推断的，而不是 JS 那样的动态类型，所以下面这个样子是不行的：

#+BEGIN_SRC java
var a = 10;
a = "abc"; //error!
#+END_SRC

其次，这个 =var= 只能用于局部变量声明，在其他地方使用都是错误的。

#+BEGIN_SRC java
class C {
    public var a = 10; //error
    public var f() { //error
        return 10;
    }
}
#+END_SRC

所以 =var= 并不会对库的接口产生影响，影响的只可能是内部的实现。

还有些人觉得 =var= 只是一个简单的语法糖，用来少打几个字符。
但其实并不仅仅是这样， =var= 还能够用来弥补 Java 8 lambda 表达式的缺陷。

我们知道 Java 8 的 lambda 表达式不能够捕获可变变量，也就是说下面这个代码是错误的：

#+BEGIN_SRC java
int count = 0;
List.of("ice1000", "Glavo").forEach(e -> count += 1); //error
System.out.println(count);
#+END_SRC

之前想要绕过这个限制，我们可以用单元素的数组实现。
而在 Java 10 中我们又多了一种选择：

#+BEGIN_SRC java
var context = new Object() {
        int count = 0;
    }
    List.of("ice1000", "Glavo").forEach(e -> context.count += 1);
System.out.println(context.count);
#+END_SRC

除了帮助我们捕获可变参数， =var= 还能够帮助我们实现嵌套函数：

#+BEGIN_SRC java
int factorial(int i) {
    var context = new Object() {
            int fact(int i, int accumulator) {
                if (i <= 1)
                    return accumulator;
                else
                    return fact(i - 1, i * accumulator);
            }
        };
    return context.fact(i, 1);
}
#+END_SRC

在使用长的 Stream 操作链的时候，我们也可以把一些操作放在 context 中，从而简化操作链，增强可读性：

#+BEGIN_SRC java
int[] parseAndLogInts(List<String> list, int radix) {
    var context = new Object() {
            int parseAndLogInt(String str) {
                System.out.println(str);
                return Integer.parseInt(str, radix);
            }
        };
    return list.stream().mapToInt(context::parseAndLogInt).toArray();
}
#+END_SRC

为了兼容原有代码， =var= 不是一个关键字，而是一个保留类型，这意味着你还是能像这样 =var= 当做一个变量名：

#+BEGIN_SRC java
void f() {
    int var = 10;
}
#+END_SRC

=var= 还有一个特殊的特性：在用匿名内部类初始化 =var= 声明的变量时，这个变量会被推断成一个局部的类型，所以你可以这样：

#+BEGIN_SRC java
final var o = new Object() {
        public void f() {
            System.out.println("Hello world!");
        }
    };
o.f();
#+END_SRC

注意我们用 =final var= 声明了不可变变量 =o= ，不过其实就算不用 =final var= 声明，你也不能把 =o= 赋值为它的初始值和 =null= 以外的任何值。

**** 并行全垃圾回收器 G1
G1 是设计来作为一种低延时的垃圾回收器（但是如果它跟不上旧的堆碎片产生的提升速率的话，将仍然采用完整压缩集合）。
在 JDK9 之前，默认的收集器是并行，吞吐，收集器。
为了减少在使用默认的收集器的应用性能配置文件的差异，G1 现在有一个并行完整收集机制。

#+BEGIN_QUOTE
- [[http://www.ajiatech.com/news/industryNews/828.html][JDK 10 的 109 项新特性]]
- [[https://www.zhihu.com/question/269244201/answer/347062385][如何评价 JDK 10？]]
#+END_QUOTE
*** DONE [Java] Splitting a comma-separated string but ignoring commas in quotes :regex:java:
CLOSED: [2018-03-24 Sat 21:04]
:PROPERTIES:
:EXPORT_FILE_NAME: split-a-comma-separated-string
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :toc false
:END:
Sometimes we need to parse strings like this:

#+BEGIN_SRC
"1234567890","James",man,"New York, NY, USA"
#+END_SRC

And the output we need is as follows:

#+BEGIN_SRC
"1234567890"
"James"
man
"New York, NY, USA"
#+END_SRC

<!--more-->

We can try the following code:

#+BEGIN_SRC java
String line = "\"1234567890\",\"James\",man,\"New York, NY, USA\"";
String[] tokens = line.split(",(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)", -1);
Arrays.stream(tokens).forEach(System.out::println);
#+END_SRC

In other words: split on the comma only if that comma has zero, or an even number of quotes ahead of it.

A bit friendlier for the eyes:

#+BEGIN_SRC java
String line = "\"1234567890\",\"James\",man,\"New York, NY, USA\"";

String otherThanQuote = " [^\"] ";
String quotedString = String.format(" \" %s* \" ", otherThanQuote);
String regex = String.format("(?x) "+ // enable comments, ignore white spaces
                             ",                         "+ // match a comma
                             "(?=                       "+ // start positive look ahead
                             "  (?:                     "+ //   start non-capturing group 1
                             "    %s*                   "+ //     match 'otherThanQuote' zero or more times
                             "    %s                    "+ //     match 'quotedString'
                             "  )*                      "+ //   end group 1 and repeat it zero or more times
                             "  %s*                     "+ //   match 'otherThanQuote'
                             "  $                       "+ // match the end of the string
                             ")                         ", // stop positive look ahead
                             otherThanQuote, quotedString, otherThanQuote);

String[] tokens = line.split(regex, -1);
Arrays.stream(tokens).forEach(System.out::println);
#+END_SRC

About =split(String regex, int limit)= method.

The /limit/ parameter controls the number of times the pattern is applied and therefore affects the length of the resulting array.

- If the /limit/ =n= is *greater than zero* then the pattern will be applied at most =n - 1= times, the array's length will be no greater than =n=, and the array's last entry will contain all input beyond the last matched delimiter.
- If =n= is *non-positive* then the pattern will be applied as many times as possible and the array can have any length.
- If =n= is *zero* then the pattern will be applied as many times as possible, the array can have any length, and trailing empty strings will be discarded.

The string "boo:and:foo", for example, yields the following results with these parameters:

| Regex | Limit | Result                        |
|-------+-------+-------------------------------|
| :     |     2 | { "boo", "and:foo" }          |
| :     |     5 | { "boo", "and", "foo" }       |
| :     |    -2 | { "boo", "and", "foo" }       |
| o     |     5 | { "b", "", ":and:f", "", "" } |
| o     |    -2 | { "b", "", ":and:f", "", "" } |
| o     |     0 | { "b", "", ":and:f" }         |

#+BEGIN_QUOTE
- [[https://stackoverflow.com/questions/1757065][Stack Overflow]]
- [[https://docs.oracle.com/javase/6/docs/api/java/lang/String.html#split(java.lang.String,%20int)][Java Doc]]
#+END_QUOTE
*** DONE Java 8 Stream 语法 :java:
CLOSED: [2018-07-14 Sat 17:53]
:PROPERTIES:
:EXPORT_FILE_NAME: java-8-stream
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :toc false
:END:
Java 8 的一个重要新特性就是 Stream。
Stream 是用函数式编程方式在集合类上进行复杂操作的工具，其集成了 Java 8 中的众多新特性之一的聚合操作，开发者可以更容易地使用 Lambda 表达式，并且更方便地实现对集合的查找、遍历、过滤以及常见计算等。

<!--more-->

学习资料
- [[https://blog.csdn.net/IO_Field/article/details/54971761][Java 8系列之Stream的基本语法详解]]
- [[https://blog.csdn.net/IO_Field/article/details/54971608][Java 8系列之Stream的强大工具Collector]]
- [[https://blog.csdn.net/io_field/article/details/54971555][Java 8系列之重构和定制收集器]]
- [[https://blog.csdn.net/IO_Field/article/details/54971679][Java 8 系列之 Stream 中万能的 reduce]]
*** DONE JVM 指令重排对双重校验锁单例模式的影响 :java:
CLOSED: [2018-10-28 Sun 18:27]
:PROPERTIES:
:EXPORT_FILE_NAME: singleton-and-jvm-instruction-rearrangement
:END:
下面的双重校验锁单例是线程安全的吗？

#+BEGIN_SRC java
public class Singleton {
    private static Singleton instance = null

        private Singleton() {}

        public static Singleton getInstance() {
            if (instance == null) {
                synchronzied(Singleton.class) {
                    if (instance == null) {
                        instance = new Singleton();
                    }
                }
            }
            return instance;
        }
}
#+END_SRC

<!--more-->

**** JVM 内存模型
Java 内存模型规定，对于多个线程共享的变量，存储在主内存当中，每个线程都有自己 *独立* 的工作内存，线程只能访问自己的工作内存，不可以访问其它线程的工作内存。
工作内存中保存了主内存共享变量的 *副本* ，线程要操作这些共享变量，只能通过操作工作内存中的副本来实现，操作完毕之后再同步回到主内存当中。
***** volatile 关键字
很多时候我们需要一个线程对共享变量的改动，其它线程也需要立即得知这个改动该怎么办呢？

Java 为此提供了 volatile 关键字，在声明变量的时候加入 volatile 关键字就可以保证变量的内存可见性，即变量改变对所有的线程都是立即可见的。

volatile 保证可见性的原理是在 *每次访问变量时都会进行一次刷新* ，因此每次访问都是主内存中最新的版本。
所以 volatile 关键字的作用之一就是保证 *变量修改* 的实时可见性。
**** 指令重排
指令重排序是 JVM 为了优化指令，提高程序运行效率进行的优化操作。
指令重排序包括编译器重排序和运行时重排序。
JVM 规范规定，指令重排序可以在不影响单线程程序执行结果前提下进行。
***** 指令重排示例
假设有这么两个共享变量 a 和 b：

#+BEGIN_SRC java
private int a;
private int b;
#+END_SRC

在线程 A 中有两条语句对这两个共享变量进行赋值操作：

#+BEGIN_SRC java
a = 1;
b = 2;
#+END_SRC

假设当线程 A 对 a 进行复制操作的时候发现这个变量在主内存已经被其它的线程加了访问锁，那么此时线程 A 怎么办？
等待释放锁？不，等待太浪费时间了，它会去尝试进行 b 的赋值操作，b这时候没被人占用，因此就会先为 b 赋值，再去为 a 赋值，那么执行的顺序就变成了：

#+BEGIN_SRC java
b = 2;
a = 1;
#+END_SRC
***** 指令重排导致出错
对于在同一个线程内，这样的改变是不会对逻辑产生影响的，但是在多线程的情况下指令重排序会带来问题。
看下面这个情景：

#+BEGIN_SRC java
// 在线程 A 中：
context = loadContext();
inited = true;

// 在线程 B 中：
while (!inited ) { //根据线程 A 中对 inited 变量的修改决定是否使用 context 变量
    sleep(100);
}
doSomethingwithconfig(context);
#+END_SRC

假设线程 A 中发生了指令重排序：

#+BEGIN_SRC java
inited = true;
context = loadContext();
#+END_SRC

那么 B 中很可能就会拿到一个尚未初始化或尚未初始化完成的 context，从而引发程序错误。
**** 指令重排导致单例模式失效
下面是一段双重校验锁单例模式：

#+BEGIN_SRC java
public class Singleton {
    private static Singleton instance = null

        private Singleton() {}

        public static Singleton getInstance() {
            if (instance == null) {
                synchronzied(Singleton.class) {
                    if (instance == null) {
                        instance = new Singleton();
                    }
                }
            }
            return instance;
        }
}
#+END_SRC

看似简单的一段赋值语句： =instance = new Singleton();= ，其实 JVM 内部已经转换为多条指令：

#+BEGIN_SRC java
memory = allocate(); //1：分配对象的内存空间
ctorInstance(memory); //2：初始化对象
instance = memory; //3：设置 instance 指向刚分配的内存地址
#+END_SRC

但是经过重排序后如下：

#+BEGIN_SRC java
memory = allocate(); //1：分配对象的内存空间
instance = memory; //3：设置 instance 指向刚分配的内存地址，此时对象还没被初始化
ctorInstance(memory); //2：初始化对象
#+END_SRC

可以看到指令重排之后，instance 指向分配好的内存放在了前面，而这段内存的初始化被排在了后面，在线程 A 初始化完成这段内存之前，线程 B 虽然进不去同步代码块，但是在同步代码块之前的判断就会发现 instance 不为空，此时线程 B 获得 instance 对象进行使用就可能发生错误。
**** 解决方法
volatile 关键字除了可以保证变量修改的可见性之外，还有另一个重要的作用：禁止指令重排序。
变量以关键字 volatile 修饰之后，就会阻止 JVM 对其相关代码进行指令重排，这样就能够按照既定的顺序指执行。

在《深入理解 Java 虚拟机》一书中提到

#+BEGIN_QUOTE
volatile 屏蔽指令重排的语义在 JDK1.5 中才被完全修复，此前的 JDK 中即使将变量声明为 volatile 也仍然不能完全避免重排序所导致的问题（主要是 volatile 变量前后的代码仍然存在重排序问题），这点也是在 JDK1.5 之前的 Java 中无法安全地使用 DCL（双锁检测）来实现单例模式的原因。
#+END_QUOTE
** Scala :@scala:
*** DONE Scala 学习资料 :@scala:
CLOSED: [2018-04-15 Sun 18:13]
:PROPERTIES:
:EXPORT_FILE_NAME: scala-materials
:END:
记录一些 Scala 的学习资料，感谢@hongjiang_wang 的整理。
[[http://hongjiang.info/scala/][原帖地址]]

<!--more-->

**** Akka
- [[http://hongjiang.info/akka-in-practice-1/][Actor 里的偏函数与性能]]
- [[http://hongjiang.info/akka-patterns-ask-with-temporary-actor/][Patterns.ask 是使用一个临时创建的 actor 发消息而非自身]]
- [[http://hongjiang.info/akka-mailbox-counter-extension/][对 actor 的邮箱计数]]
- [[http://hongjiang.info/never-ever-block-an-actor/][Never ever block an actor]]
**** 模式匹配
- [[http://hongjiang.info/scala-pattern-matching-1/][话说模式匹配(1) 什么是模式？]]
- [[http://hongjiang.info/scala-pattern-matching-2/][话说模式匹配(2) scala 里是怎么实现的?]]
- [[http://hongjiang.info/scala-pattern-matching-3/][话说模式匹配(3) 模式匹配的核心功能是解构！]]
- [[http://hongjiang.info/scala-pattern-matching-4/][话说模式匹配(4) 赋值语句与模式匹配]]
- [[http://hongjiang.info/scala-pattern-matching-5/][话说模式匹配(5) for 表达式中的模式匹配]]
- [[http://hongjiang.info/scala-pattern-matching-6/][话说模式匹配(6) case 类的细节]]
- [[http://hongjiang.info/scala-pattern-matching-7/][话说模式匹配(7) 一个构造器模式的例子(by case class)]]
- [[http://hongjiang.info/scala-pattern-matching-8/][话说模式匹配(8) 一个抽取器的例子]]
**** 类型相关
- [[http://hongjiang.info/scala-type-and-class/][scala 类型系统：1) 类型与类]]
- [[http://hongjiang.info/scala-type-system-classof-and-getclass/][scala 类型系统：2) classOf 与 getClass 方法的差异]]
- [[http://hongjiang.info/scala-type-system-singleton-type/][scala 类型系统：3) 单例类型]]
- [[http://hongjiang.info/scala-type-system-inner-type-and-type-projection/][scala 类型系统：4) 内部类，路径依赖类型&类型投影]]
- [[http://hongjiang.info/scala-type-system-structural-type/][scala 类型系统：5) 结构类型]]
- [[http://hongjiang.info/scala-type-system-compund-type/][scala 类型系统：6) 复合类型与 with 关键字]]
- [[http://hongjiang.info/scala-type-system-infix-type/][scala 类型系统：7) 中缀类型]]
- [[http://hongjiang.info/scala-type-system-type-keyword/][scala 类型系统：8) type 关键字]]
- [[http://hongjiang.info/scala-type-system-self-type/][scala 类型系统：9) this 别名&自身类型]]
- [[http://hongjiang.info/scala-intersection-type-and-union-type/][scala 类型系统：10) 交集类型与联合类型]]
- [[http://hongjiang.info/scala-upper-bounds-and-lower-bounds/][scala 类型系统：11) upper bounds & lower bounds]]
- [[http://hongjiang.info/scala-type-system-view-bounds/][scala 类型系统：12) view bounds]]
- [[http://hongjiang.info/scala-type-system-context-bounds/][scala 类型系统：13) context bounds]]
- [[http://hongjiang.info/scala-type-system-multiple-bounds/][scala 类型系统：14) multiple bounds]]
- [[http://hongjiang.info/scala-covariance-and-contravariance/][scala 类型系统：15) 协变与逆变]]
- [[http://hongjiang.info/scala-function-type/][scala 类型系统：16) 函数类型]]
- [[http://hongjiang.info/scala-structural-type-detail/][scala 类型系统：17) 结构类型的细节问题]]
- [[http://hongjiang.info/scala-type-system-volatile-type/][scala 类型系统：18) 不稳定(volatile)类型]]
- [[http://hongjiang.info/scala-type-system-manifest-vs-typetag/][scala 类型系统：19) Manifest 与 TypeTag]]
- [[http://hongjiang.info/scala-type-system-array-type/][scala 类型系统：20) 数组类型]]
- [[http://hongjiang.info/scala-type-specialization/][scala 类型系统：21) type specialization 与类爆炸]]
- [[http://hongjiang.info/scala-type-contraints-and-specialized-methods/][scala 类型系统：22) 类型约束与特定方法]]
- [[http://hongjiang.info/scala-type-evidence-and-union-type/][scala 类型系统：23) 用类型证明实现联合类型]]
- [[http://hongjiang.info/scala-higher-kinded-type/][scala 类型系统：24) 理解higher-kinded-type]]
- [[http://hongjiang.info/scala-type-lambda/][scala 类型系统：25) type lambda]]
- [[http://hongjiang.info/scala-type-classes-pattern/][scala 类型系统：26) type classes 模式]]
- [[http://hongjiang.info/scala-type-classes-review/][scala 类型系统：27) 回顾常见的 type classes]]
- [[http://hongjiang.info/scala-type-system-dependent-types/][scala 类型系统：28) 依赖类型]]
- [[http://hongjiang.info/scala-case-class-and-algebraic-data-type/][scala 类型系统：case class 与代数数据类型]]
- [[http://hongjiang.info/scala-type-inference/][scala 类型系统：类型推导]]
- [[http://hongjiang.info/scala-curry-howard-isomorphism/][scala 类型系统：柯里-霍华德同构]]
- [[http://hongjiang.info/scala-value-class-in-array/][scala 类型系统：值类型与数组]]
- [[http://hongjiang.info/scala-null-and-nothing/][scala 类型系统：Null 与 Nothing，造型问题]]
- [[http://hongjiang.info/scala-value-classes-detail/][scala 类型系统：值类型的细节]]
- [[http://hongjiang.info/scala-universal-traits/][scala 类型系统：通用特质(universal traits)]]
- [[http://hongjiang.info/scala-value-class-boxing-question/][scala 类型系统：值类型的装箱问题]]
- [[http://hongjiang.info/scala-value-classes/][scala 类型系统：值类型的一些限制]]
**** Shapeless
- [[http://hongjiang.info/shapeless-1-polymorphic-question/][shapeless(1): 从方法与函数的多态谈起]]
- [[http://hongjiang.info/shapeless-2-polymorphic-function-impl/][shapeless(2): 对函数(值)实现参数化多态]]
**** 类型推导相关
- [[http://hongjiang.info/generic-methods-2-partially-applied-functions/][泛型方法转换为部分应用函数时的类型推导问题]]
**** Spray
- [[http://hongjiang.info/spray-magnet-pattern/][spray 中的 Magnet 模式: typeclass 的一种特定方式]]
**** Monads & Monoids
- [[http://hongjiang.info/understand-monad-0/][我所理解的 monad(0)]]
- [[http://hongjiang.info/semigroup-and-monoid/][我所理解的 monad(1)：半群(semigroup)与幺半群(monoid)]]
- [[http://hongjiang.info/fold-and-monoid/][我所理解的 monad(2)：fold 与 monoid]]
- [[http://hongjiang.info/semigroup-and-parallel/][我所理解的 monad(3)：半群(semigroup)与并行运算]]
- [[http://hongjiang.info/understand-monad-4-what-is-functor/][我所理解的 monad(4)：函子(functor)是什么]]
- [[http://hongjiang.info/understand-monad-5-what-is-endofunctor/][我所理解的 monad(5)：自函子(Endofunctor)是什么]]
- [[http://hongjiang.info/understand-monad-6-combinator/][我所理解的 monad(6)：从组合子(combinator)说起]]
- [[http://hongjiang.info/understand-monad-7-action-combinator/][我所理解的 monad(7)：把 monad 看做行为的组合子]]
**** 翻译&笔记
- [[http://hongjiang.info/programming-in-scala-notes/][Programming in Scala 的阅读笔记]]
- [[http://hongjiang.info/effective-scala-chinese/][Effective Scala 中文版]]
- [[http://hongjiang.info/monads-are-elephants-part1-chinese][翻译 monads-are-elephants 第一部分]]
- [[http://hongjiang.info/monads-are-elephants-part2-chinese][翻译 monads-are-elephants 第二部分]]
- [[http://hongjiang.info/monads-are-elephants-part3-chinese][翻译 monads-are-elephants 第三部分]]
**** Scala pitfalls
- [[http://hongjiang.info/scala-pitfalls-0/][scala 雾中风景(0): 序]]
- [[http://hongjiang.info/scala-pitfalls-1/][scala 雾中风景(1): lambda 表达式的缩写]]
- [[http://hongjiang.info/scala-pitfalls-2/][scala 雾中风景(2): 小括号与花括号]]
- [[http://hongjiang.info/scala-pitfalls-3/][scala 雾中风景(3): for 表达式的背后]]
- [[http://hongjiang.info/scala-pitfalls-4/][scala 雾中风景(4): Unit 类型]]
- [[http://hongjiang.info/scala-pitfalls-5/][scala 雾中风景(5): 中缀表达]]
- [[http://hongjiang.info/scala-pitfalls-6/][scala 雾中风景(6): 内部类与模式匹配]]
- [[http://hongjiang.info/scala-pitfalls-7/][scala 雾中风景(7): val x:Int = x + 1 的问题]]
- [[http://hongjiang.info/scala-pitfalls-8/][scala 雾中风景(8): 高阶函数与 Unit 的谜题]]
- [[http://hongjiang.info/scala-pitfalls-9/][scala 雾中风景(9): List(1,2,3) == Seq(1,2,3) ?]]
- [[http://hongjiang.info/scala-pitfalls-10/][scala 雾中风景(10): 逆变点与协变点]]
- [[http://hongjiang.info/scala-pitfalls-11-type-erasure/][scala 雾中风景(11): isInstanceOf 与类型擦拭]]
- [[http://hongjiang.info/scala-app-trait-delay-init/][scala 雾中风景(12): App 特质的延迟初始化]]
- [[http://hongjiang.info/scala-pitfalls-13/][scala 雾中风景(13): 模式匹配中的逻辑或]]
- [[http://hongjiang.info/scala-pitfalls-14/][scala 雾中风景(14): trait 的泛型参数为何不支持 context bounds]]
- [[http://hongjiang.info/scala-pitfalls-15/][scala 雾中风景(15): class A { type T }与 class A[T] {}]]
- [[http://hongjiang.info/scala-pitfalls-16/][scala 雾中风景(16): println(1,2,3)为什么 work?]]
- [[http://hongjiang.info/scala-pitfalls-17/][scala 雾中风景(17): toSet()的谜题]]
- [[http://hongjiang.info/scala-pitfalls-18/][scala 雾中风景(18): postfix operator 的问题]]
- [[http://hongjiang.info/scala-pitfalls-19/][scala 雾中风景(19): MutableList 与 mutable.LinkedList 的问题]]
- [[http://hongjiang.info/scala-pitfalls-20/][scala 雾中风景(20): MutableList 迭代器的 bug]]
- [[http://hongjiang.info/scala-pitfalls-21-auto-tupling-and-auto-detupling/][scala 雾中风景(21): auto-tupling 与 auto-detupling]]
- [[http://hongjiang.info/scala-pitfalls-22/][scala 雾中风景(22): var 变量与赋值操作符]]
- [[http://hongjiang.info/scala-pitfalls-23-nothing-caused-npe/][scala 雾中风景(23): Nothing 类型引发的 NullPointerException]]
- [[http://hongjiang.info/scala-pitfalls-24/][scala 雾中风景(24): break 与异常捕获]]
- [[http://hongjiang.info/scala-pitfalls-25-try-finally-expr-type-infer/][scala 雾中风景(25): try-finally 表达式的类型推导]]
- [[http://hongjiang.info/scala-pitfalls-26/][scala 雾中风景(26): 变量查找的问题]]
**** 诊断
- [[http://hongjiang.info/scala-diagnose-1/][scala 的诊断方法(1) 使用-Xprint:typer 看语法糖的背后]]
- [[http://hongjiang.info/scala-diagnose-2/][scala 的诊断方法(2) 在 repl 下用 reify 查看表达式的翻译结果]]
- [[http://hongjiang.info/scala-diagnose-3/][scala 的诊断方法(3) 在 repl 下统计方法的执行时间]]
- [[http://hongjiang.info/scala-diagnose-4/][scala 的诊断方法(4) -Ytyper-debug 编译项]]
- [[http://hongjiang.info/scalac-aspects/][scala 的诊断方法(5) 用 scalac-aspects 诊断 scalac 各阶段耗时]]
**** 函数与函数式风格
- [[http://hongjiang.info/scala-parenthesis-and-apply/][无参方法与小括号问题]]
- [[http://hongjiang.info/scala-uniform-access-principle/][scala 中的无参方法与统一访问原则]]
- [[http://hongjiang.info/scala-eta-conversion/][scala 中的 eta-conversion]]
- [[http://hongjiang.info/closure-var-banding/][闭包变量绑定问题]]
- [[http://hongjiang.info/scala-quicksort/][如何写一段符合 scala 语言习惯的快速排序]]
- [[http://hongjiang.info/double-pound-sign-and-hashcode/][Any.##方法与 hashCode 的区别]]
- [[http://hongjiang.info/scala-named-arguments/][scala 中的有名参数]]
- [[http://hongjiang.info/scala-canbuildfrom-detail/][map 函数，隐式参数 CanBuildFrom 的细节]]
- [[http://hongjiang.info/scala-function-polymorphic/][scala 中函数类型的多态]]
- [[http://hongjiang.info/scala-vs-ocaml/][scala 不是函数式语言，与 Ocaml 的对比]]
- [[http://hongjiang.info/foldleft-and-foldright/][foldLeft 与 foldRight]]
- [[http://hongjiang.info/eta-conversion-and-eta-expansion/][再谈 eta-conversion 与 eta-expansion]]
- [[http://hongjiang.info/currying-and-builder-pattern/][柯里化(currying)与构造器(Builder)模式]]
**** 集合相关
- [[http://hongjiang.info/tuple-iterator/][对 tuple 进行迭代]]
- [[http://hongjiang.info/string-as-collection/][String 当作集合处理时的方法]]
- [[http://hongjiang.info/scala-union-diff-intersect/][scala 中集合的交集、并集、差集]]
- [[http://hongjiang.info/tuple1-purpose/][Tuple1 的存在意义？]]
- [[http://hongjiang.info/why-tuples-only-to-22/][为什么 scala 中的 tuple 定义了 22 个(Tuple22)?]]
- [[http://hongjiang.info/scala-any2arrowassoc/][二元组箭头表达式背后的语法糖]]
- [[http://hongjiang.info/scala-list-apply/][通过 List.apply 方法构造 List 的背后逻辑]]
**** API pitfalls
- [[http://hongjiang.info/scala-api-pitfalls-1/][scala 类库中的 api 陷阱(1): LinkedList.append]]
**** REPL 相关
- [[http://hongjiang.info/repl-misc/][repl 杂记]]
- [[http://hongjiang.info/scala-repl-modes/][repl 下的几种模式]]
- [[http://hongjiang.info/scala-repl-javap/][repl 下的 javap]]
- [[http://hongjiang.info/scala-repl-kind/][scala2.11 的 repl 下增加了 kind 命令]]
**** Scala 2.10+
- [[http://hongjiang.info/scala210-eval-script/][scala2.10 中 eval 一段 script]]
- [[http://hongjiang.info/scala210-repl-cp-do-not-work/][scala2.10.1 的 repl 下:cp 命令不能工作]]
- [[http://hongjiang.info/scala-sip-18/][scala2.10 中采纳了 SIP-18:模块化语言特性]]
- [[http://hongjiang.info/for-comprehension-val-definition/][scala2.10 里的 for 表达式已经不允许对变量声明 val]]
- [[http://hongjiang.info/scala-compiler-delambdafy/][scala2.11 编译环节的一些变动: delambdafy]]
- [[http://hongjiang.info/scala-211-compiler-lint/][scala2.11 编译器对 lint 的增强]]
**** 未分类
- [[http://hongjiang.info/scala-lazy-and-dcl/][lazy 变量与双重检测锁(DCL)]]
- [[http://hongjiang.info/scala-static-forwarders/][scala 里的静态代理(static-forwarders)]]
- [[http://hongjiang.info/scala-counting…ated-character/][统计诗经中最常使用的叠词]]
- [[http://hongjiang.info/serializable-annotation-deprecated/][scala2.9 中@serializable 注释已不鼓励使用]]
- [[http://hongjiang.info/scala-package-root-prefix/][import _root_.xxx 中的_root_前缀表示 xxx 包名是绝对路径]]
- [[http://hongjiang.info/scala-process/][scala 中执行外部命令(scala.sys.process)]]
- [[http://hongjiang.info/classloader-question-on-import-classes/][classloader 问题：import my.package._ 是否会 load 该包下所有的 class?]]
- [[http://hongjiang.info/scala-unicode-reserved-words/][scala 中有 Unicode 的关键字]]
- [[http://hongjiang.info/cannot-find-soucecode-of-class-any/][Any 类的源码在哪儿？]]
- [[http://hongjiang.info/scala-compiler-bug/][scala 编译器的一个 bug]]
- [[http://hongjiang.info/scala-bug-210-object-as-type/][scala bug 系列：2.10 编译器把单例当作类型的 bug]]
- [[http://hongjiang.info/scala-simulate-javascript-generator/][scala 里模拟 javascript/python 里的生成器的效果]]
- [[http://hongjiang.info/null-cast-to-value-type/][null 造型为值类型时为何不抛异常]]
- [[http://hongjiang.info/scala-int-unbox-for-null/][Int 与 Integer 的拆箱问题]]
- [[http://hongjiang.info/functional-programming-in-scala-chinese-version/][Scala 函数式编程中文版已上架]]
- [[http://hongjiang.info/scala-style-checker/][scalastyle 工具]]
**** 分享与交流
- [[http://hongjiang.info/scala-function-and-closure/][分享 ppt: scala 中的函数与闭包]]
- [[http://hongjiang.info/scala-19lou/][与 19 楼的交流]]
- [[http://hongjiang.info/scala-shanghai-512/][上海 scala 爱好者聚会(2013)]]
- [[http://hongjiang.info/adc2013/][阿里技术嘉年华 2013]]
- [[http://hongjiang.info/scala-hangzhou-2013-1019/][2013 华东 scala 爱好者聚会(杭州)]]
- [[http://hongjiang.info/scala-shanghai-2014/][华东地区 scala 爱好者聚会(2014 上海)]]
- [[http://hongjiang.info/scala-shanghai-2015/][华东地区 scala 爱好者聚会(2015 上海)]]
- [[http://hongjiang.info/scala-in-wacai/][Scala 在挖财的应用实践]]
- [[http://hongjiang.info/archsummit-beijing-2015/][ArchSummit 北京 2015 小记]]
**** 依赖注入
- [[http://hongjiang.info/cake-pattern-and-di/][Cake Pattern 与依赖注入]]
- [[http://hongjiang.info/scala-self-type-and-di/][scala 中的 self type(自身类型)与依赖注入]]
** Build :@build:
*** DONE 通过 Gradle 打包外部依赖 :gradle:build:
CLOSED: [2018-03-03 Sat 19:04]
:PROPERTIES:
:EXPORT_FILE_NAME: package-dependency-via-gradle
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :toc false
:END:
有时候我们需要通过 Gradle 将依赖打包进 Jar 包中，下面代码中的 =fatJar= 任务可以实现此功能。

<!--more-->

#+BEGIN_SRC groovy
group 'com.example'
version '0.1.0'

apply plugin: 'java'

sourceCompatibility = 1.8

repositories {
    mavenCentral()
}

dependencies {
    compile fileTree(dir: 'lib', include: '*.jar')
    compile group: 'org.apache.kafka', name: 'kafka-clients', version: '1.0.0'
    compile group: 'org.slf4j', name: 'slf4j-simple', version: '1.7.25'
    testCompile group: 'junit', name: 'junit', version: '4.12'
}

tasks.withType(JavaCompile) {
    options.encoding = "UTF-8"
}

task fatJar(type: Jar) {
    manifest {
        attributes 'Main-Class': 'com.example.stk.Main'
    }
    from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } }
    with jar
}
#+END_SRC

另外， =dependencies= 代码块中的 =fileTree= 用于将外部的依赖包通过 Gradle 管理。

=attributes 'Main-Class': 'com.example.stk.Main'= 指定 Jar 包的主类。
** Linux :@linux:
*** DONE Git Clone 下载速度慢的解决方法 :tip:git:
CLOSED: [2018-04-30 Mon 20:09]
:PROPERTIES:
:EXPORT_FILE_NAME: git-clone-slow-solution
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :toc false
:END:
在国内 Git clone 仓库奇慢无比，通过以下配置可以提升下载速度。

#+BEGIN_SRC sh
git config --global http.postBuffer 524288000
#+END_SRC
*** DONE Linux 下清空 Page cache :page_cache:linux:
CLOSED: [2018-11-08 Thu 00:09]
:PROPERTIES:
:EXPORT_FILE_NAME: clear-page-cache
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :toc false
:END:
使用下面这条命令：

#+BEGIN_SRC sh
sync; echo 1 > /proc/sys/vm/drop_caches
#+END_SRC

<!--more-->

*sync 命令:*

Linux sync 命令用于数据同步，sync 命令是在关闭 Linux 系统时使用的。

Linux 系统中欲写入硬盘的资料有的时候会了效率起见，会写到 filesystem buffer 中，这个 buffer 是一块记忆体空间，如果欲写入硬盘的资料存于此 buffer 中，而系统又突然断电的话，那么资料就会流失了，sync 指令会将存于 buffer 中的资料强制写入硬盘中。

*/proc/sys/vm/drop_caches:*

- To free pagecache, use:
  #+BEGIN_SRC sh
echo 1 > /proc/sys/vm/drop_caches
  #+END_SRC
- To free dentries and inodes, use:
  #+BEGIN_SRC sh
echo 2 > /proc/sys/vm/drop_caches
  #+END_SRC
- To free pagecache, dentries and inodes, use:
  #+BEGIN_SRC sh
echo 3 >/proc/sys/vm/drop_caches
  #+END_SRC
** Windows :@windows:
*** DONE Windows 下使用 Powershell 批量重命名文件 :powershell:windows:
CLOSED: [2018-03-18 Sun 18:47]
:PROPERTIES:
:EXPORT_FILE_NAME: powershell-bulk-rename
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :toc false
:END:
当我们下载了一部电视剧或是动漫时，通常文件名非常长，会包含视频的分辨率、字幕组等信息，但是我们通常只会关心这是第几集。。。

<!--more-->

于是就开始寻找 Windows 下批量重命名的方法。
虽然 Windows 下的命令行没有 Linux 下方便，但是还是提供了必备的功能。

以下就是通过 Powershell 实现批量正则重命名文件。

#+BEGIN_SRC sh
Get-ChildItem *.mp4 | Rename-Item -NewName { $_.name -replace '.*Vol\.([0-9]{1}).*', 'Video_$1.mp4' }
#+END_SRC

其中管道前是列出所有 mp4 文件。
=Rename-Item= 的一般形式是 =Rename-Item -Path <String> -NewName <String>= 。
大括号内是通过正则替换字符串。

另外 =Get-ChildItem= 的别名是 =ls= ， =Rename-Item= 的别名是 =rni= 。
* Algorithm :@algorithm:
** Heuristic :@heuristic_algorithm:
*** DONE 用遗传算法求解 N 皇后问题 :genetic_algorithm:
CLOSED: [2018-03-11 Sun 00:07]
:PROPERTIES:
:EXPORT_FILE_NAME: solving-n-queens-problem-with-genetic-algorithm
:END:
**** N 皇后问题
首先介绍八皇后问题。八皇后问题是一个以国际象棋为背景的问题：如何能够在 =8×8= 的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？
为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。

八皇后问题可以推广为更一般的 N 皇后摆放问题：这时棋盘的大小变为 =N×N= 。

<!--more-->

**** 遗传算法
遗传算法（Genetic Algorithm, GA）是借鉴生物界自然选择和自然遗传机制的启发式搜索算法。
它模拟一个人工种群的进化过程，通过选择、交叉以及变异等机制，在每次迭代中都保留一组候选个体，重复此过程，种群经过若干代进化后，理想情况下其适应度达到近似最优的状态。
***** 算法过程
总结一下是下列几个步骤：
1. 初始化种群（Initial population）
2. 计算适应度（Fitness function）
3. 选择（Selection）
4. 交叉（Crossover）
5. 变异（Mutation）

用伪代码来描述就是：

#+BEGIN_SRC
START
Generate the initial population
Compute fitness
REPEAT
    Selection
    Crossover
    Mutation
    Compute fitness
UNTIL population has converged
STOP
#+END_SRC
***** 编码与解码
实现遗传算法的第一步就是明确对求解问题的编码和解码方式。

一般有两种编码方式，各具优缺点：
- 实数编码：直接用实数表示基因，容易理解且不需要解码过程，但容易过早收敛，从而陷入局部最优。
- 二进制编码：稳定性高，种群多样性大，但需要的存储空间大，需要解码且难以理解。

在本问题中可以采用实数编码，例如，当 =N = 8= 时，其中一个编码可以是 =78563412= ，其中每一个数字的位置代表皇后在棋盘上的行数，每一个值代表皇后在当前行中所出列的位置。
比如 =6= 代表该皇后在棋盘的第 4 行第 6 列。
***** 个体与种群
“染色体”表达了某种特征，这种特征的载体，称为“个体”。
许多这样的个体组成了一个种群。
***** 适应度函数
遗传算法中，一个个体（解）的好坏用适应度函数值来评价。
在本问题中，有多少皇后满足要求就是适应度函数。

适应度函数值越大，解的质量越高。
适应度函数是遗传算法进化的驱动力，也是进行自然选择的唯一标准，它的设计应结合求解问题本身的要求而定。
***** 选择
选择操作是从前代种群中选择多对较优个体，一对较优个体称之为一对父母，让父母们将它们的基因传递到下一代，直到下一代个体数量达到种群数量上限。

在选择操作前，将种群中个体按照适应度从小到大进行排列。

采用轮盘赌选择方法（当然还有很多别的选择方法），各个个体被选中的概率与其适应度函数值大小成正比。
轮盘赌选择方法具有随机性，在选择的过程中可能会丢掉较好的个体，所以可以使用精英机制，将前代最优个体直接选择。

在本问题中，直接将适应度最高的两个个体作为父母。
***** 交叉
两个待交叉的不同的染色体（父母）根据交叉概率按某种方式交换其部分基因。
一般来说交叉概率比较大。

可以采用单点交叉法，也可以使用其他交叉方法，应根据实际情况定义合适的交叉算法。
***** 变异
染色体按照变异概率进行染色体的变异。一般来说变异概率比较小。

可以采用单点变异法，也可以使用其他变异方法。
**** Java 实现
#+BEGIN_SRC java
import java.util.*;
import java.util.stream.Collectors;

public class Queen {
    private static int N = 10;
    private static double RATE = 0.3;

    public static void main(String[] args) {
        Queen queen = new Queen();
        HashSet<String> result = new HashSet<>();
        int[] father = queen.init();
        int[] mother = queen.init();
        int times = 3000000;
        for (int i = 0; i < times; i++) {
            List<Integer[]> son = new ArrayList<>();
            for (int j = 0; j < N; j++) {
                son.add(Arrays.stream(queen.crossover(father, mother)).boxed().toArray(Integer[]::new));
            }
            son = queen.mutation(son);
            Map<Integer[], Integer> res = queen.selection(son);
            for (Map.Entry<Integer[], Integer> c : res.entrySet()) {
                if (c.getValue() == 0) result.add(Arrays.toString(c.getKey()));
            }
            father = Arrays.stream(res.entrySet().iterator().next().getKey()).mapToInt(k -> k).toArray();
            mother = Arrays.stream(res.entrySet().iterator().next().getKey()).mapToInt(k -> k).toArray();
        }
        System.out.println("Solutions: " + result.size());
    }

    private int[] init() {
        List<Integer> list = new ArrayList<>();
        for (int i = 1; i <= N; i++) list.add(i);
        Collections.shuffle(list);
        return list.stream().mapToInt(i -> i).toArray();
    }

    private int[] crossover(int[] originFather, int[] originMother) {
        int[] father = Arrays.copyOf(originFather, N);
        int[] mother = Arrays.copyOf(originMother, N);
        int[] rend = new int[N];
        for (int i = 0; i < N; i++) {
            rend[i] = Math.random() >= 0.5 ? 0 : 1;
        }
        int[] son = new int[N];
        int f = 0, m = 0;
        for (int i = 0; i < N; i++) {
            if (rend[i] == 0) {
                for (f = 0; f < N; f++) if (father[f] != 0) break;
            } else {
                for (m = 0; m < N; m++) if (mother[m] != 0) break;
            }
            son[i] = rend[i] == 0 ? father[f] : mother[m];
            for (int j = 0; j < N; j++) {
                if (father[j] == son[i]) father[j] = 0;
                if (mother[j] == son[i]) mother[j] = 0;
            }
        }
        return son;
    }

    private List<Integer[]> mutation(List<Integer[]> chromosomes) {
        for (Integer[] chromosome : chromosomes) {
            if (Math.random() < RATE) continue;
            int i = (int) (Math.random() * N);
            int j = (int) (Math.random() * N);
            if (i == j) continue;
            chromosome[i] ^= chromosome[j];
            chromosome[j] ^= chromosome[i];
            chromosome[i] ^= chromosome[j];
        }
        return chromosomes;
    }

    private Integer fitness(Integer[] result) {
        int res = 0;
        for (int i = 0; i < N; i++) {
            for (int j = i + 1; j < N; j++) {
                if (Math.abs(result[i] - result[j]) == j - i) res++;
            }
        }
        return res;
    }

    private Map<Integer[], Integer> selection(List<Integer[]> son) {
        Map<Integer[], Integer> result = son.stream().collect(Collectors.toMap(x -> x, this::fitness));
        result = result.entrySet().stream().sorted(Map.Entry.comparingByValue()).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -> oldValue, LinkedHashMap::new));
        return result;
    }
}
#+END_SRC
**** N 皇后解的个数
|  N |        Solutions |
|----+------------------|
|  1 |                1 |
|  2 |                0 |
|  3 |                0 |
|  4 |                2 |
|  5 |               10 |
|  6 |                4 |
|  7 |               40 |
|  8 |               92 |
|  9 |              352 |
| 10 |              724 |
| 11 |             2680 |
| 12 |            14200 |
| 13 |            73712 |
| 14 |           365596 |
| 15 |          2279184 |
| 16 |         14772512 |
| 17 |         95815104 |
| 18 |        666090624 |
| 19 |       4968057848 |
| 20 |      39029188884 |
| 21 |     314666222712 |
| 22 |    2691008701644 |
| 23 |   24233937684440 |
| 24 |  227514171973736 |
| 25 | 2207893435808352 |

#+BEGIN_QUOTE
- [[https://www.zhihu.com/question/23293449][知乎 - 如何通俗易懂地解释遗传算法？有什么例子？]]
#+END_QUOTE
*** DONE 启发式算法概述 :heuristic_algorithm:
CLOSED: [2018-10-28 Sun 15:42]
:PROPERTIES:
:EXPORT_FILE_NAME: heuristic-algorithm-overview
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :toc false
:END:
启发式算法（Heuristic Algorithm）是相对于最优化算法提出的。它有不同的定义：
- 其中一种是，一个基于直观或经验构造的算法，在可接受的花费（指计算时间和空间）下给出待解决组合优化问题每一个实例的一个可行解，该可行解与最优解的偏离程度一般不能被预计。
- 另一种是，启发式算法是一种技术，这种技术使得在可接受的计算成本内去搜寻最好的解，但不一定能保证所得的可行解和最优解，甚至在多数情况下，无法阐述所得解同最优解的近似程度。

<!--more-->

启发式算法是一种近似算法，它更像是一种算法框架，定义了算法的流程步骤，并没有成型的理论体系。

有一类的通用启发式策略称为元启发式算法（Metaheuristic），通常使用乱数搜寻技巧。
他们可以应用在非常广泛的问题上，但不能保证效率。
近年来随着智能计算领域的发展，出现了一类被称为超启发式算法（Hyper-Heuristic Algorithm）的新算法类型。

以下表格是对启发式算法的分类：

|                | 传统启发式算法 | 元启发式算法 | 超启发式算法                   |
|----------------+----------------+--------------+--------------------------------|
| 搜索空间       | 由实例解构成   | 由实例解构成 | 由启发式算法构成               |
| 问题的领域知识 | 需要           | 需要         | 不需要（或很少需要）           |
| 典型类别       | 局部搜索       | 蚁群算法     | 基于随机选择的超启发式算法     |
|                | 爬山法         | 粒子群算法   | 基于贪心策略的超启发式算法     |
|                | 贪心法         | 模拟退火算法 | 基于元启发式算法的超启发式算法 |
|                |                | 遗传算法     | 基于学习的超启发式算法         |
|                |                | 禁忌搜索     |                                |
|                |                | 进化规划     |                                |
|                |                | 进化策略     |                                |
|                |                | 变邻域搜索   |                                |
|                |                | 人工神经网络 |                                |
*** DONE 粒子群算法 :particle_swarm_optimization:heuristic_algorithm:
CLOSED: [2018-10-28 Sun 15:42]
:PROPERTIES:
:EXPORT_FILE_NAME: particle-swarm-optimization
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :mathjax true :mathjaxEnableSingleDollar true
:END:
**** 粒子群算法 （Particle Swarm Optimization, PSO）
粒子群算法，也称粒子群优化算法或鸟群觅食算法，来源于对一个简化社会模型的模拟。
PSO 算法属于进化算法的一种，和模拟退火算法相似，它也是从随机解出发，通过迭代寻找最优解，它也是通过适应度来评价解的品质，但它比遗传算法规则更为简单，它没有遗传算法的“交叉”（Crossover）和“变异”（Mutation）操作，它通过追随当前搜索到的最优值来寻找全局最优。
这种算法以其实现容易、精度高、收敛快等优点引起了学术界的重视，并且在解决实际问题中展示了其优越性。
粒子群算法是一种并行算法。

<!--more-->

**** 算法原理
设想这样一个场景：一群鸟在随机搜索食物。
在这个区域里只有一块食物。
所有的鸟都不知道食物在那里。
但是他们知道当前的位置离食物还有多远。
那么找到食物的最优策略是什么呢。
最简单有效的就是搜寻目前离食物最近的鸟的周围区域。

PSO 从这种模型中得到启示并用于解决优化问题。
PSO 中，每个优化问题的解都是搜索空间中的一只鸟。
我们称之为“粒子”。
所有的粒子都有一个由被优化的函数决定的适应值（fitness value），每个粒子还有一个速度决定他们飞翔的方向和距离。
然后粒子们就追随当前的最优粒子在解空间中搜索。

PSO 算法是基于群体的，根据对环境的适应度将群体中的个体移动到好的区域。
然而它不对个体使用演化算子，而是将每个个体看作是$D$维搜索空间中的一个没有体积的微粒（点），在搜索空间中以一定的速度飞行，这个速度根据它本身的飞行经验和同伴的飞行经验来动态调整。
第$i$个微粒表示为 $X_i = (x_{i1}, x_{i2}, ..., x_{iD})$ ，它经历过的最好位置（有最好的适应值）记为 $P_i = (p_{i1}, p_{i2}, ..., p_{iD})$ ，也称为 $pBest$ 。
在群体所有微粒经历过的最好位置的索引号用符号 $g$ 表示，即 $P_g$ ，也称为 $gBest$ 。
微粒 $i$ 的速度用 $V_i = (v_{i1}, v_{i2}, ..., v_{iD})$ 表示。
对每一代，它的第 $d$ 维 $(1 ≤ d ≤ D)$ 根据如下方程进行变化：

$$v_{id} = w \cdot v_{id} + c_1 \cdot rand() \cdot (p_{id} - x_{id}) + c_2 \cdot rand() \cdot (p_{gd} - x_{id})$$

$$x_{id} = x_{id} + v_{id}$$

其中 $w$ 为惯性权重（Inertia Weight）， $c_1$ 和 $c_2$ 为加速常数（Acceleration Constants），rand()为在[0,1]范围里变化的随机值。
此外，微粒的速度 $V_i$ 被一个最大速度 $V_{max}$ 所限制。
如果当前对微粒的加速导致它的在某维的速度 $v_{id}$ 超过该维的最大速度 $v_{max,d}$ ，则该维的速度被限制为该维最大速度 $v_{max,d}$ 。
**** 算法流程
1. 初始化一群微粒（群体规模为 $m$ ），包括随机的位置和速度；
2. 评价每个微粒的适应度；
3. 对每个微粒，将它的适应值和它经历过的最好位置 $pBest$ 的作比较，如果较好，则将其作为当前的最好位置 $pBest$ ；
4. 对每个微粒，将它的适应值和全局所经历最好位置 $gBest$ 的作比较，如果较好，则重新设置 $gBest$ 的索引号；
5. 根据上述方程变化微粒的速度和位置；
6. 如未达到结束条件（通常为足够好的适应值或达到一个预设最大代数$G_{max}$），回到 2。
* Research :@research:
** DONE Tips for conducting a Systematic Literature Review :tip:slr:
CLOSED: [2017-08-07 Mon 14:33]
:PROPERTIES:
:EXPORT_FILE_NAME: tips-for-conducting-a-slr
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :toc false
:END:
A good systematic review might achieve most or all of the following (Baumeister & Leary, 1997; Bem, 1995; Cooper, 2003):

<!--more-->

- Establish to what extent existing research has progressed towards clarifying a particular problem;
- Identify relations, contradictions, gaps, and inconsistencies in the literature, and explore reasons for these (e.g., by proposing a new conceptualisation or theory which accounts for the inconsistency);
- Formulate general statements or an overarching conceptualization (make a point, rather than summarizing all the points everyone else has made; Sternberg, 1991);
- Comment on, evaluate, extend, or develop theory;
- In doing these things, provide implications for practice and policy;
- Describe directions for future research.
** DONE 什么会和“Ops”碰撞出火花？ :devops:aiops:operations:
CLOSED: [2017-09-09 Sat 08:12]
:PROPERTIES:
:EXPORT_FILE_NAME: xops
:END:
最近 AIOps 非常火，加上之前对 DevOps 做了一些研究，现在找了一些带有 Ops 的词，在此做了一些整理。

<!--more-->

*** DevOps
DevOps（英文 Development 和 Operations 的组合）是一组过程、方法与系统的统称，用于促进开发（应用程序/软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合。
它的出现是由于软件行业日益清晰地认识到：为了按时交付软件产品和服务，开发和运营工作必须紧密合作。
*** AIOps
AIOps，也就是基于算法的 IT 运维（Algorithmic IT Operations），是由 Gartner 定义的新类别，源自业界之前所说的 ITOA (IT Operations and Analytics)。
我们已经到达了这样的一个时代，数据科学和算法正在被用于自动化传统的 IT 运维任务和流程。
算法被集成到工具里，帮助企业进一步简化运维工作，把人类从耗时又容易出错的流程中解放出来。人们不再需要在遗留的管理系统中定义和管理无穷无尽的规则和过滤器。

#+BEGIN_QUOTE
- [[https://www.quora.com/What-are-algorithmic-IT-operations-AIOps][What are algorithmic IT operations (AIOps)?]]
- [[http://www.infoq.com/cn/news/2017/06/AIOps-ai-relation][AIOps 是什么？它与 AI 有什么关系？]]
#+END_QUOTE
*** DevSecOps
DevSecOps 是糅合了开发、安全及运营理念以创建解决方案的全新方法，是 DevOps 与 SecOps 的结合。
DevSecOps 的作用和意义建立在 *每个人都对安全负责* 的理念之上，其目标是在不影响安全需求的情况下快速的执行安全决策，将决策传递至拥有最高级别环境信息的人员。

DevSecOps 宣言：
1. CIO 驱动
2. 不同团队间的相互协作
3. 专注于风险，而非安全

#+BEGIN_QUOTE
- [[http://www.devsecops.org/blog/2015/2/15/what-is-devsecops][What is DevSecOps?]]
- [[http://devopsagenda.techtarget.com/opinion/The-DevOps-concept-NoOps-DataOps-and-what-comes-next][The DevOps concept: NoOps, DataOps and what comes next]]
- [[http://blog.oneapm.com/apm-tech/643.html][DevSecOps 简介（一）]]
- [[http://blog.oneapm.com/apm-tech/507.html][什么是 DevSecOps？系列（一）]]
#+END_QUOTE
*** BizDevOps
BizDevOps，也被称作 DevOps 2.0，是一种鼓励开发、运维和业务团队携手合作的软件开发方式，使组织能够更快地开发软件，更好地响应用户需求，最终实现收益最大化。

#+BEGIN_QUOTE
- [[http://searchsoftwarequality.techtarget.com/definition/BizDevOps-Business-Development-and-Operations][BizDevOps (Business, Development and Operations)]]
#+END_QUOTE
*** DataOps
DataOps (data operations) 是一种设计、实施和维护分布式数据架构的方法，这些数据架构支持实际生产中大多数的开源工具和框架。
受 DevOps 运动的启发，DataOps 力求加快运行在大数据处理框架上的应用生产。
像 DevOps 一样，DataOps 旨在打破 IT 运维和软件开发团队的壁垒，鼓励业界利益相关者同数据工程师，数据科学家和分析师之间的合作，以最灵活，最有效的方式使用该组织的数据来实现正面的业务成果。

#+BEGIN_QUOTE
- [[http://searchdatamanagement.techtarget.com/definition/DataOps][DataOps (data operations)]]
- [[http://devopsagenda.techtarget.com/opinion/The-DevOps-concept-NoOps-DataOps-and-what-comes-next][The DevOps concept: NoOps, DataOps and what comes next]]
- [[https://en.wikipedia.org/wiki/DataOps][Wiki]]
#+END_QUOTE
*** NoOps
NoOps (no operations) 是一种理念，IT 环境可以从基础架构进行自动化和抽象化，不需要专门的团队来管理内部软件。
在 NoOps 场景下，维护和一些其他的由运维执行的任务将会被自动实施。
NoOps 背后的两个主要驱动力是 IT 自动化和云计算。

#+BEGIN_QUOTE
- [[http://searchcloudapplications.techtarget.com/definition/noops][NoOps]]
- [[http://devopsagenda.techtarget.com/opinion/The-DevOps-concept-NoOps-DataOps-and-what-comes-next][The DevOps concept: NoOps, DataOps and what comes next]]
#+END_QUOTE
*** ChatOps
ChatOps 在 GitHub 上广受赞誉，是指由对话驱动的开发。
将工具植入到对话当中，使用被关键插件和脚本改良过的聊天机器人，团队能够自动执行任务和协作，效果更好、成本更低、速度更快。

以下是项目经理的观点：在聊天室里，团队成员输入命令来配置机器人，它们通过自定义脚本和插件来执行命令，从代码部署到安全事件响应再到团队成员提醒，范围极广。随着命令被不断执行，整个团队协作也实时进行。

#+BEGIN_QUOTE
- [[http://searchitoperations.techtarget.com/definition/ChatOps][ChatOps]]
- [[http://devopsagenda.techtarget.com/opinion/ChatOps-and-VoiceOps-make-DevOps-integration-easier-than-ever][ChatOps and VoiceOps make DevOps integration easier than ever]]
- [[http://www.csdn.net/article/a/2017-04-10/15926999][DevOps 理念升级，ChatOps 概述及实践经验]]
- [[http://blog.daocloud.io/chatops-pagerduty/][ChatOps 是什么？该如何使用呢？]]
#+END_QUOTE
*** VoiceOps
相对于 ChatOps，VoiceOps 更进了一步，它将虚拟语音助手集成到了运维工具中。

#+BEGIN_QUOTE
- [[http://devopsagenda.techtarget.com/opinion/ChatOps-and-VoiceOps-make-DevOps-integration-easier-than-ever][ChatOps and VoiceOps make DevOps integration easier than ever]]
#+END_QUOTE
*** SecOps
同 DevOps 统一开发和运维类似，SecOps 是解决安全团队和运维团队隔阂的管理方法。
SecOps 将安全和运维团队联系起来，共同分担责任，分享流程和使用工具，以此在不牺牲安全性的前提下维持正常运行时间和性能。

#+BEGIN_QUOTE
- [[https://www.govloop.com/what-is-secops/][What is SecOps?]]
#+END_QUOTE
*** WebOps
WebOps (Web operations) 是处理 Web 应用和其支持系统中复杂事务的 IT 系统管理领域。
WebOps 工程领域包括应用部署、管理、维护、配置和修复。

优秀的 WebOps 工程师会对以下技术有深入的理解：网络、路由、交换、防火墙、负载均衡、高可用、灾难恢复、TCP 和 UDP 服务、NOC 管理、硬件规格、多种不同 UNIX 发行版、多种 Web 服务器技术、缓存技术、多种数据库、存储基础设施、密码学、算法、容量规划。

#+BEGIN_QUOTE
- [[http://whatis.techtarget.com/definition/WebOps-Web-operations][WebOps (Web operations)]]
#+END_QUOTE
*** HumanOps
HumanOps 是一套关注运行基础设施人力方面的原则。
它强调了运行系统团队的重要性，而不仅仅是系统本身。
基础设施的健康状况不仅仅是硬件、软件、自动化和正常运行时间 —— 它还包括团队的健康和福利。
HumanOps 的目标是改善和保持团队的健康：促进沟通，减少疲劳和减轻压力。

#+BEGIN_QUOTE
- [[https://github.com/HumanOps/HumanOps/blob/master/HumanOps.rst][HumanOps]]
- [[http://devopsagenda.techtarget.com/opinion/DevOps-and-HumanOps-Efficiency-meets-empathy][DevOps and HumanOps: Efficiency meets empathy]]
#+END_QUOTE
*** DesignOps
基于 DevOps 的理念和实践，DesignOps 有助于优化开发者和设计师之间的沟通和协作，以便更快的生产更好的产品。

#+BEGIN_QUOTE
- [[http://searchsoftwarequality.techtarget.com/news/450421998/DesignOps-Bridging-the-developer-designer-communication-gap][DesignOps: Bridging the developer, designer communication gap]]
#+END_QUOTE
*** Anti-DevOps
Anti-DevOps 是一种反对 DevOps 革命的理念。
已经有 DevOps 的批评者抱怨 DevOps 是在“杀死开发人员”，或者 DevOps 只适用于像 Netflix 和 Google 这样的大型组织。
如果这样的情绪大量聚集，软件组织可能会重新采用传统软件交付模式而推迟 DevOps 的实施。

#+BEGIN_QUOTE
- [[http://devopsagenda.techtarget.com/opinion/The-DevOps-concept-NoOps-DataOps-and-what-comes-next][The DevOps concept: NoOps, DataOps and what comes next]]
#+END_QUOTE
** DONE 智能时代的新运维「CNUTCon 2017 上海」 :aiops:devops:operations:
CLOSED: [2017-09-17 Sun 12:39]
:PROPERTIES:
:EXPORT_FILE_NAME: cnutcon2017
:END:
在今年的 9 月 10 至 11 日，有幸获得导师的邀请，参加了全球运维技术大会。
这篇博客记录了会上一些有意思的内容。
文章写的比较随意，主要是给自己看 ~(￣▽￣)~*

<!--more-->

*** 开场
主持人介绍了运维的演变过程。

运维的演变：

SA → Ops → DevOps → SRE

运维平台的演变：

流程化 → 工具化 → Web 化 → 自动化 → 智能化

最后提了新运维下的热门技术：
- DevOps
- AIOps
- Serverless
- SRE
- 智能化运维
- 自动化运维
*** 为什么说 AIOps 是未来，百度的思考与实践
百度做了一个运维自动化的能力分级，类似于 CMMI。

[[/cnutcon2017/baidu-aiops.png]]
*** 基于日志 trace 的智能故障定位系统
日志抽样的方式：
- 匀质抽样
- 异常抽样
- 人工抽样
*** CNUTCon 夜聊：谈谈智能时代的新运维
阿里许晓斌讲师认为：需要智能化运维是因为应用程序不易运维。
他更关注 Cloud Native。
与其运维系统做的好，不如应用更好的去适应云。
*** 微服务场景下的 Serverless 架构实践
什么是 Serverless：

[[/cnutcon2017/serverless-definition.png]]

Serverless 的优缺点以及未来：

[[/cnutcon2017/serverless-summery.png]]

日志管理平台：

[[/cnutcon2017/serverless-log-platform.png]]
*** 天猫 DevOps 转型实践
天猫内部正在编写给新人的 DevOps 权威指南。
我们很希望能得到天猫的支持，但是很遗憾，文档仅供内部使用，并不开放。
*** 基于虚拟化的 CI/CD 流程与基础架构建设
美团使用 Jenkins 作为 CI 服务器的原因：
- 开源，插件开发成本低。
- 社区活跃，技术成熟，培训成本低。
- 安全性。可以部署在私有系统上。

为什么要自研部署系统：
- 部署场景比较复杂，需要适应实际的业务需求，特别是关系到生产环境，现有的系统不合适。
- 而 Jenkins 作为 CI 系统满足了大部分需求，各个厂商都差不多。
*** 全方位的监控与智能透明的自动化运维
一些日志工具：

[[/cnutcon2017/log-solution.png]]

其中 graylog 可以根据需求拉取特定日志。

[[/cnutcon2017/chatops.png]]

ChatOps 可以方便移动运维。
IBM 有 70%的时间在用 Chatbot。

[[http://www.cnutcon.com/][CNUTCon 2017 官网 →]]
** DONE 编译中文 LaTeX :tip:latex:
CLOSED: [2017-09-22 Fri 09:15]
:PROPERTIES:
:EXPORT_FILE_NAME: compile-latex-in-chinese
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :toc false
:END:
之前想用中文写 LaTeX，查了几次总是忘记，在此记录。

<!--more-->

只要在文件开头加入以下代码：

#+BEGIN_SRC latex
% !TEX program = xelatex
\documentclass{ctexart}
#+END_SRC
** DONE How to choose an open source license? :tip:license:open_source:
CLOSED: [2017-09-27 Wed 13:45]
:PROPERTIES:
:EXPORT_FILE_NAME: choose-an-open-source-license
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :toc false
:END:
This is a simple description of popular free software license made by [[http://paulmillr.com/][Paul Miller]].

<!--more-->

[[/open-source-license/open-source-licenses.png]]

Choosing an open source license can be really confusing. Fortunately, GitHub has created [[https://choosealicense.com/][ChooseALicense.com]] to help us make that decision.
* Emacs :@emacs:
** DONE Org mode 导出中文 PDF :org_mode:latex:emacs:
CLOSED: [2019-01-29 Tue 01:32]
:PROPERTIES:
:EXPORT_FILE_NAME: org-mode-export-pdf-in-chinese
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :toc false
:END:
只要在文件开头加入以下代码

<!--more-->

#+BEGIN_SRC org
,#+LATEX_COMPILER: xelatex
,#+LATEX_HEADER: \usepackage{xeCJK}
#+END_SRC
* Reading :@reading:
** DONE 大型网站技术架构读书笔记 :architecture:
CLOSED: [2016-07-10 Sun 14:57]
:PROPERTIES:
:EXPORT_FILE_NAME: notes-on-technical-architecture-of-large-websites
:END:
本文为《大型网站技术架构：核心原理与案例分析》的读书笔记。

<!--more-->

*** 大型网站架构模式
- 分层：分层业务
- 分割：同层业务进行分割，如购物、论坛、搜索、广告
- 分布式
  + 分布式应用和服务
  + 分布式静态资源
  + 分布式数据和存储
  + 分布式计算
- 集群
- 缓存
  + CDN
  + 反向代理
  + 本地缓存
  + 分布式缓存
- 异步
- 冗余
- 自动化
- 安全
*** 大型网站核心架构要素
性能、可用性、伸缩性、扩展性和安全性
*** 网站的高性能架构
**** Web 前端性能优化
- 浏览器访问优化
  + 减少 http 请求
  + 使用浏览器缓存
  + 启用压缩
  + CSS 放在页面最上面，JavaScript 放在页面最下面
  + 减少 Cookie 传输
- CDN 加速
- 反向代理
**** 应用服务器性能优化
- 分布式缓存
  + 频繁修改的数据：不要缓存频繁修改的数据。
  + 没有热点的访问：大部分数据访问应该集中在小部分数据。
  + 数据不一致与脏读：容忍数据的不一致。
  + 缓存可用性：分布式缓存服务器集群。
  + 缓存预热：在缓存系统启动时就把数据加载好。
  + 缓存穿透：将不存在的数据也缓存（value 值为 null）。
- 异步操作
- 使用集群
- 代码优化
  + 多线程
  + 资源复用：单例和对象池
  + 数据结构
  + 垃圾回收
**** 存储性能优化
- 机械硬盘 vs. 固态硬盘
- B+树 vs. LSM 树
- RAID vs. HDFS
*** 网站的高可用架构
**** 高可用的应用
- 通过负载均衡进行无状态服务的失效转移
- 应用服务器集群的 Session 管理
  + Session 复制：适用小型网站。
  + Session 绑定：将同一 IP 的请求分发到同一台服务器。极少使用。
  + 利用 Cookie 记录 Session：将 Session 记录在客户端，每次请求就发送到服务器。
  + 服务器处理后将修改的 Session 响应给客户端。
  + Session 服务器
**** 高可用的服务
- 分级管理：服务优先级
- 超时设置
- 异步调用：消息队列
- 服务降级
  + 拒绝服务：拒绝低优先级应用的调用。
  + 关闭功能：关闭部分不重要的服务，或者服务内部关闭部分不重要的功能。
- 幂等性设计：在服务层保证服务重复调用和调用一次产生的结果相同。
**** 高可用的数据
- CAP 原理
  + 数据一致性 Consistency
    * 数据强一致性：各个副本总是一致。
    * 数据用户一致：各个副本可能不一致，通过纠错和校验机制确定一个一致的数据给用户。
    * 数据最终一致：一段时间后一致。
  + 数据可用性 Availability
  + 分区耐受性 Partition Tolerance
- 数据备份
  + 冷备份：物理存储，无法保证数据最终一致性。
  + 热备份：异步热备份和同步热备份。
- 失效转移
  + 失效确认：心跳检测和应用程序访问失败报告。
  + 访问转移
  + 数据恢复
**** 软件质量保障
- 网站发布
- 自动化测试
- 预发布验证
- 代码控制：版本控制
- 自动化发布
- 灰度发布：部分发布
**** 网站运行监控
- 监控数据采集
  + 用户行为日志收集
    * 服务器端日志收集
    * 客户端浏览器日志收集
  + 服务器性能监控
  + 运行数据报告
- 监控管理
  + 系统报警
  + 失效转移
  + 自动优雅降级
*** 网站的伸缩性架构
**** 网站架构的伸缩性设计
- 不同功能进行物理分离实现伸缩
- 单一功能通过集群规模实现伸缩
**** 应用服务器集群的伸缩性设计
- HTTP 重定向负载均衡：根据用户的 HTTP 请求计算真实的服务器地址，并写入 HTTP 重定向响应中返回。

  优点是简单。
  缺点是两次请求，性能差；
  重定向服务器可能成为瓶颈，集群伸缩性规模有限；
  HTTP302 响应码重定向可能使搜索引擎判断为 SEO 作弊，降低排名。
  因此不多见。

  [[/notes-on-technical-architecture-of-large-websites/redirect-load-balance.jpg]]

- DNS 域名解析负载均衡：在 DNS 中映射多个 IP，根据算法返回 IP 地址。

  大型网站总是部分使用 DNS 域名解析，作为第一级的负载均衡手段，得到的服务器同样也是负载均衡的内部服务器，最后将请求分发到真实的服务器上。

  [[/notes-on-technical-architecture-of-large-websites/dns-load-balance.jpg]]

- 反向代理负载均衡：优点是负载均衡和反向代理集成在一起，部署简单。缺点是可能成为瓶颈。

  [[/notes-on-technical-architecture-of-large-websites/reverse-proxy-load-balance.jpg]]

- IP 负载均衡：将用户请求的目的地址修改为真实服务器地址，并接收响应，最后修改源地址返回给用户。

  [[/notes-on-technical-architecture-of-large-websites/ip-load-balance.jpg]]

- 数据链路层负载均衡：将真实服务器设置和负载均衡服务器相同的虚拟 IP，把用户请求的 mac 地址修改为真实服务器，服务器直接响应到用户。

  [[/notes-on-technical-architecture-of-large-websites/data-link-load-balance.jpg]]

- 负载均衡算法
  + 轮询（Round Robin, RR）
  + 加权轮询（Weighted Round Robin, WRR）
  + 随机（Random）：也可以用加权随机算法。
  + 最少连接（Least Connections）：分发到连接最少的服务器上。
  + 源地址散列（Source Hashing）：把 IP 地址进行 Hash 计算。
**** 数据存储服务器集群的伸缩性设计
- 关系数据库集群：主从读写分离、分库（业务分割）、分片（将一张表拆分）。
- NoSQL 数据库：Apache HBase
** DONE 关于《自控力》 :self_control:
CLOSED: [2018-11-22 Thu 01:43]
:PROPERTIES:
:EXPORT_FILE_NAME: about-self-control
:END:
读完《自控力》后在此对一些重要观点进行记录。

<!--more-->

*** 第一章 我要做，我不要，我想要：什么是意志力？为什么意志力至关重要？
#+BEGIN_QUOTE
核心思想：意志力实际上是“我要做” “我不要”和“我想要”这三种力量。它们协同努力，让我们变成更好的自己。
#+END_QUOTE

- 牢记自己真正想要的是什么。
- 增强意志力的一件简单、无痛的事--冥想。神经学家发现，如果你经常让大脑冥想，它不仅会变得擅长冥想，还会提升你的自控力，提升你集中注意力、管理压力、克制冲动和认识自我的能力。
- 自控力是一个过程，在这个过程中，人们不断偏离目标，又不断把注意力收回来。
- 每个意志力挑战都是一次自我博弈。
*** 第二章 意志力的本能：人生来就能抵制奶酪蛋糕的诱惑
#+BEGIN_QUOTE
核心思想：意志力是种生理本能，它和压力一样，通过不断进化来保护我们不受自身伤害。
#+END_QUOTE

- 三思而后行：先让自己放慢速度，而不是给自己加速（比如应激反应）。
- 任何给你的身心带来压力的东西都会影响自控力的生理基础，甚至会摧毁你的意志力。
- 通过呼吸实现自控：将呼吸频率降低到每分钟 4～6 次。
- 自控力的良药是锻炼。
- 充足的睡眠可以帮助获得更强的意志力。
- 为了能够保持健康、维持幸福生活，你需要放弃对意志力的完美控制。即便你增强了自己的意志力，你也不可能完全控制自己想什么、感觉什么、说什么或者做什么。你需要明智地使用意志力的能量。
- 从压力和自控力中恢复的最佳途径就是放松。
- 当我处在慢性压力中，迎接意志力挑战的是最冲动的自己，想要赢得意志力挑战，我们需要调整到正确的身心状态，用能量去自控，而不是自卫。这就意味着，我们需要从压力中恢复过来，保证有能量做最好的自己。
*** 第三章 累到无力抵抗：为什么自控力和肌肉一样有极限？
#+BEGIN_QUOTE
核心思想：自控力就像肌肉一样有极限。自控力用得太多会疲惫，但坚持训练能增强自控力。
#+END_QUOTE

- 意志力的肌肉模式告诉我们，自控力从早上到晚上会逐渐减弱。
- 突然增加的糖分会让你在短期内面对紧急情况时有更强的意志力。但从长远来说，过度依赖糖分并不是自控的好方法。
- “自控力肌肉”锻炼模式：
  + 增强“我不要”的力量：不随便发誓、用不常用的手进行日常活动等。
  + 增强“我想要”的力量：每天都做一些事（但不是你已经在做的事），用来养成习惯或不再找借口。
  + 增强自我监控能力：认真记录一件你平常不关注的事。
- 自控力的极限和身体的极限是一样的道理，也就是说，我们总是在意志力真正耗尽之前就感到无法坚持了。
- 如果我们想增强自控力，就要考虑如何支撑住最疲惫的自己，而不是指望最理想的自己突然出现来拯救生活。
- 我们面临的挑战是，像聪明的运动员那样去训练，去提升我们的极限，但要一步一个脚印地去做。当我们虚弱的时候，我们能从动力中汲取能量。同样，我们也能让疲惫的自己做出明智的选择。
*** 第四章 容忍罪恶：为何善行之后会有恶行？
#+BEGIN_QUOTE
核心思想：当我们将意志力挑战看成衡量道德水平的标准时，善行就会允许我们做坏事。为了能够更好地自控，我们需要忘掉美德，关注目标和价值观。
#+END_QUOTE

- 我们很容易认为，纵容自己就是对美德最好的奖励。我们忘记了自己真正的目标，向诱惑屈服了。
- “道德许可”最糟糕的部分并不是它可疑的逻辑，而是它会诱使我们做出背离自己最大利益的事。它让我们相信，放弃节食、打破预算、多抽根烟这些不良行为都是对自己的“款待”。
- 不要把支持目标实现的行为误认为是目标本身。不是说你做了一件和你目标一致的事情，你就不会再面临危险了。
- 进步可能会让我们放弃曾经为之奋斗的东西。
- “道德许可”并不只计算过去的善行，我们同样可能看到未来，认为我们计划要做的善行也值得称赞。
- 我们不断期望明天能做出和今天不同的选择，但这种期望是错误的。
- 如果我们预料到自己无法完成设定的目标，那么还不如在开始之前就认输。如果我们现在表现糟糕，却用对未来的乐观期待来演示它，那么还不如一开始就不要设定这个目标。
- 当“光环效应”（只关注一个事物最有益的品质，而忽视其他）影响到你的意志力挑战时，你需要找到最具体的测量标准（比如卡路里、花费、消耗或浪费的时间），以此判断这个选择是否和你的目标相符。
- 如果只是按照“正确”和“错误”来判断做过的事，而不是牢记我们真正想要的东西，就会带来与目标相抵触的冲动，并允许我们做出妨碍自己的行动。想要做到始终如一，我们就需要认同目标本身，而不是我们做善事时的光环。
*** 第五章 大脑的弥天大谎：为什么我们误把渴望当幸福？
#+BEGIN_QUOTE
核心思想：我们的大脑错把奖励的承诺当作快乐的保证，所以，我们会从不可能带来满足的事物中寻找满足感。
#+END_QUOTE

- 多巴胺的首要功能是让我们追求快乐，而不是让我们快乐。
- 虽然我们所处的世界总让我们产生欲望，但我们只要用心观察，就能看透一些东西。知道那是怎么一回事并不能完全消除你的欲望，但它能让你至少有机会抗争一下，锻炼一下“我不要”力量。
- 我们误把渴望的感觉当作了快乐。
- 当我们把自己从错误的奖励承诺中解放出来时，我们常常发现，我们误以为的快乐源泉，其实正是痛苦的根源。
- 如果我们想拥有自控力，就需要区分让我们的生活有意义的真实奖励，和让我们分散精力、上瘾的虚假奖励。
*** 第六章 “那又如何”：情绪低落为何会使人屈服于诱惑？
#+BEGIN_QUOTE
核心思想：情绪低落会使人屈服于诱惑，摆脱罪恶感会让你变得更强大。
#+END_QUOTE

- 当你感到压力时，你的大脑就会指引着你，让你去做它认为能带给你快乐的事情。
- “恐惧管理”的方法能让我们不去想那个不可避免的死亡。但当我们在诱惑中寻找慰藉的时候，我们是在不自觉地加速迈向坟墓的脚步。
- 导致更多堕落的行为并不是第一次的放弃，而是第一次放弃后产生的羞耻感、罪恶感、失控感和绝望感。一旦你陷入了这样的循环，似乎除了继续做下去，就没有别的出路了。当你（又一次）责备自己（又一次）屈服于诱惑的时候，往往会带来更多意志力的失败，造成更多的痛苦。但是， 你寻求安慰的东西并不能中断这个循环，它只会给你带来更深切的罪恶感。
- 自我批评会降低积极性和自控力，而且也是最容易导致抑郁的因素。它不仅耗尽了“我要做”的力量，还耗尽了“我想要”的力量。相反，自我同情则会提升积极性和自控力。
- 在个人挫折面前，持自我同情态度的人比持自我批评态度的人更愿意承担责任。他们也更愿意接受别人的反馈和建议，更可能从这种经历中学到东西。
- 我们必须避免常见的意志力陷阱，即用“改变的承诺”而不是“改变”来改善我们的心情。
*** 第七章 出售未来：及时享乐的经济学
#+BEGIN_QUOTE
核心思想：我们无法明确地预知未来，这为我们带来了诱惑，让我们拖延着不做某些事。
#+END_QUOTE

- 当你觉得自己无法做到“不会有下一次”的时候，不妨用“10 分钟延迟法则”来增强你的自控力。
- 在这 10 分钟里，一定要时刻想着长远的奖励，抵制住诱惑。
*** 第八章 传染：为什么意志力会传染？
#+BEGIN_QUOTE
核心思想：自控受到社会认同的影响，这使得意志力和诱惑都具有传染性。
#+END_QUOTE

- 我们个人的选择在很大程度上会受他人想法、意愿和行为的影响。甚至，我们认为他们想要我们做什么，都会影响我们的选择。
- 研究发现，我们很容易感染别人的目标，从而改变自己的行为。
- 目标传染在两个方向上都会起作用--你既可以感染自控，也可能感染自我放纵。
- 在每天刚开始的时候花几分钟想想自己的目标，想想你会怎么受到诱惑，想要改变自己的目标。
- 当我们看到别人忽视规则、受欲望支配的时候，我们更可能在任何冲动面前选择屈服。
- 如果我们想让别人更有意志力，就要让他们相信自控是个社会规范。
- 在考虑如何做出选择时，我们经常想象自己是别人评估的对象。这为人们自控提供了强大的精神支持。预想自己实现目标后会非常自豪的人，更有可能坚持到底并获得成功，预想自己的行为会受到谴责也很有效。
- 即使面对诱惑，自豪的力量也会让你安然度过。
- 想象别人的目光是很有激励作用，但如果我们失败了，别人毫不掩饰的轻蔑目光则会让我们羞于公开露面。
- 把意志力挑战变成集体项目。
*** 第九章 别读这章：“我不要”力量的局限性
#+BEGIN_QUOTE
核心思想：试图压抑自己的想法、情绪和欲望，只会产生相反的效果，让你更容易去想、去感受、去做 你原本最想逃避的事。
#+END_QUOTE

- 人越是想摆脱某种想法，这种想法就越可能回到意识中，这并不意味着这个想法是真实的，也不意味着这个想法很重要。
- 去想自己所想，追随自己的感觉，这是治疗焦虑、抑郁、嗜食和各种上瘾症状的有效方法。放弃控制内心感受，反而能让我们更好的控制外在行为。
- 如果我们控制思想和行为失败了，我们会认为是自己压抑得不够，而不会认为压抑思想的方法根本行不通。这反而会使我们更强烈地想要压抑自己。
- 直面自身欲望，但不要付诸行动。
- 把“我不要”变成“我想要”
** DONE 如何成为卓有成效的管理者？ :management:
CLOSED: [2020-03-08 Sun 18:39]
:PROPERTIES:
:EXPORT_FILE_NAME: how-to-be-an-effective-executive
:END:
读完《卓有成效的管理者》后在此对一些重要观点进行记录。

<!--more-->

*** 掌握自己的时间
有效的管理者知道应该将他们的时间用在什么地方。
他们所能控制的时间非常有限，他们会有系统地工作，来善用这有限的时间。
**** 记录时间
时间是最稀有的资源，通常是一项限制因素，因为时间的供给丝毫没有弹性。

要提高管理者的有效性，第一步就是记录时间耗用的实际情形。

时间记录可以使用小册子自己记录。
但重要的是必须在处理某一工作的“当时”立即加以记录，而不能事后凭记忆补记。
**** 管理时间
***** 如何诊断自己的时间
试问以下几个问题：
1. 首先要找出什么事根本不必做，这些事做了也完全是浪费时间，于最终的成果无助。
2. 时间记录上的哪些活动可以由别人代为参加而又不影响效果。
3. 还有一项时间浪费的因素，是管理者自己可以控制并且可以消除的，这项因素是：管理者在浪费别人的时间。

   一个简单的方法可以诊断出来：去问问你的下属。
***** 消除浪费时间的活动
1. 找出由于缺乏制度或远见而产生时间浪费的因素。

   应注意的现象，是机构中一而再，再而三出现同样的“危机”。
   同样的危机如果出现了第二次，就绝不应该再让它出现第三次。

   一项重复出现的危机应该是可以预见的，并不仅限于组织的较低层次。
   组织中的每一部门都深受其害。
   同一个危机如果重复出现，往往是疏忽和懒散造成的。
   同理，一个管理上了轨道的组织，常常是一个令人觉得兴味索然的组织。
2. 人员过多，也常造成时间的浪费。

   判断人数是否过多，有一个靠得住的标准。
   如果一个高级管理人员，尤其是经理，不得不将他工作时间的 1/10 花在处理所谓的“人际关系问题”上，花在处理纠纷和摩擦上，花在处理争执和合作问题上，那么这个单位人数就过多了。
3. 另一个常见的浪费时间的原因，是组织不健全。其表现就是会议太多。

   会议是组织缺陷的一种补救措施。
   会议太多，表示职位结构不当，也表示单位设置不当。
   会议太多，表示本应由一个职位或一个单位做的工作，分散到几个职位或几个单位去了。
   同时表示职责混乱以及未能将信息传送给需要的人员。
4. 最后一项浪费时间的因素，是信息功能不健全。

   另一种同样常见的现象，是信息的表达方式不当，其后果有时更为严重。
**** 统一安排时间
第一步应先估计究竟有多少“自由时间”真正是他自己的时间，然后保留出相当分量的一段连续性的整块时间来。
一旦发现还有别的事情在“蚕食”他保留的时间，便立刻再仔细分析他的时间记录，再将其中比较次要的工作重新过滤一次。

对时间的控制与管理不能一劳永逸。
要持续不断地做时间记录，定期对这些记录进行分析，还必须根据自己可以支配的时间的多少，给一些重要的活动定下必须完成的期限。
*** 我能贡献什么
有效的管理者重视对外界的贡献。
他们并非为工作而工作，而是为成果而工作。
他们不会一接到工作就一头钻进去，更不会一开头就探究工作的技术和手段，他们会首先自问：“别人期望我做出什么成果？”
**** 管理者的承诺
有效性表现在以下三个方面：
1. 自己的工作，包括工作内容、工作水准、工作标准及其影响；
2. 自己与他人的关系，包括对上司、同事和下属；
3. 各项管理手段的运用，例如会议或报告等。

一般机构对成效的要求往往表现在以下三个方面：
1. 直接成果；
2. 树立新的价值观及对这些价值观的重新确认；
3. 培养与发明明天所需要的人才。
**** 正确的人际关系
有效人际关系的基本要求：
1. 互相沟通；
2. 团队合作；

   强调贡献有助于横向的沟通，因此能够促进团队合作。
3. 自我发展；

   个人能否有所发展，在很大程度上要看你是否重视贡献。
4. 培养他人。

   重视贡献的管理者必然会同时启发他人寻求自我发展。
**** 有效的会议
有效的管理者在会议开始时，会先说明会议的目的和要求达成的贡献。
同时，他还要设法让会议紧紧围绕着主题。
他绝不会使会议成为一次摆龙门阵的机会，任大家随便发言。
当然，如果会议的目的是在激发大家的思想和创见，他也不会仅让某一个人滔滔不绝。
他会刺激每一位与会人员的发言兴趣。
但是在会议结束之前，，他会回到开场所介绍的主题，使会议获得的结论与主题相符。
*** 如何发挥人的长处
有效的管理者善于利用长处，包括自己的长处、上司的长处、同事的长处和下属的长处。
他们还善于抓住有利形势，做他们能做的事。
他们不会把工作建立在自己的短处上，也绝不会去做自己做不了的事。
**** 要用人所长
如何用人才能既发挥他人的长处，又不致陷入因人设事的陷阱呢？
大致来说，不外乎下面 4 个原则：
1. 卓有成效的管理者不会认为职位是上天或上帝创造的。

   要将自己管辖下的职位都设置得合情合理。
   一旦发现某职位设计不当，他会立刻重新设计，而不会设法寻找天才来担任，他知道组织的好坏不是由天才来验证的。
   只有“让平凡人都能做出不平凡的事”的组织，才是好的组织。
2. 职位的要求要严格，而涵盖要广。

   这是说，合理的职位，是对具有才干的人的挑战。
   同时因为职位的涵盖很广，所以人们可以把与任务有关的优势转化为切实的成果。
3. 卓有成效的管理者在用人时，会先考虑某人能做什么，而不是先考虑职位的要求是什么。

   有效的管理者，通常有他自己的一套与众不同的考评方式。
   这套方式，第一步是列出对某人过去职务和现任职务所期望的贡献，再把某人的实际绩效记录与这项期望贡献相对照，然后检讨下面 4 个问题：
   1. 哪方面的工作他确实做得很好？
   2. 因此，哪方面的工作他可能会做得更好？
   3. 为了充分发挥他的长处，他还应该再学习或获得哪些知识？
   4. 如果我有个儿子或女儿，我愿意让我的子女在他的指导下工作吗？愿意或不愿意的理由是什么？
4. 卓有成效的管理者知道在用人之所长的同时，必须容忍人之所短。
**** 充分发挥自己的长处
有效的管理者会顺应自己的个性特点，不会勉强自己。
他注意的是自己的绩效、自己的成果，从而发展出自己的工作方式来。
*** 要事优先
有效的管理者集中精力于少数重要的领域，在这少数重要的领域中，如果能有优秀的绩效就可以产生卓越的成果。
他们会按照工作的轻重缓急设定优先次序，而且坚守优先次序。
他们别无选择，只能要事第一。
重要的事先做，不重要的事放一放，甚至不做，两种事都做，反倒会一事无成。
**** 摆脱昨天
一位希望自己有效，也希望其组织有效的管理者，必然会自我检视一切的方案、活动和任务。
他会问：“这件事现在还有继续做的价值吗？”
如果认为没有价值了，他便立即停手，而将时间精力转移到其他只要做得好，便能使自己更为有效的任务上，也能促使他的组织更为成功。
**** 先后次序的考虑
以下是几条可帮助确定优先次序的重要原则，每条都与勇气密切相关：
- 重将来而不重过去；
- 重视机会，不能只看到困难；
- 选择自己的方向，而不盲从；
- 目标要高，要有新意，不能只求安全和容易。
*** 决策的要素
决策的五点特征：
1. 要确实了解问题的性质，如果问题是经常性的，那就只能通过一项建立规则或原则的决策才能解决。

   我们常犯的错误，便是误将“经常问题”视为一连串的“偶发问题”。
   换言之，没有了解问题症结所在的基础，对问题缺乏经常性的认识与原则，其结果自然是失败与无效的。

   另一种常犯的错误，是误将真正的新问题视为旧病复发，因而仍旧应用旧原则。

   第三种常见的错误，是对某些根本性问题的界定似是而非。

   最后一种错误，是只看到问题的部分，而没有看清全貌。
2. 要确实找出解决问题时必须满足的界限，换言之，应找出问题的“边界条件”。

   通常，探求边界条件的方法，是探求“解决某一问题应有什么最低需要”。
3. 仔细思考解决问题的正确方案是什么以及这些方案必须满足哪些条件，然后再考虑必要的妥协、适应及让步事项，以期该决策能被接受。

   不必为了使建议容易被接受而想到折中。
   必须先告诉别人什么是“正确的”，才能有“正确的折中”。
4. 决策方案要同时兼顾执行措施，让决策变成可以被贯穿的行动。

   若要化决策为行动，首先必须明确无误地回答下面几个问题：
   - 谁应该了解这项决策？
   - 应该采取什么行动？
   - 谁采取行动？
   - 这些行动应如何进行，才能使执行人能够执行？
5. 在执行的过程中重视反馈，以印证决策的正确性及有效性。

   若想了解赖以做出决策的前提是否仍然有效，或者是否已经过时，亲自检查才最为可靠。
*** 有效的决策
有效的管理者必须善于做有效的决策。他们知道有效的决策事关处事的条理和秩序问题，也就是如何按正确的次序采取正确的步骤。
他们知道一项有效的决策，总是在“不同意见讨论”的基础上做出的判断，它绝不会是“一致意见”的产物。
他们知道快速的决策多为错误的决策，真正不可或缺的决策数量并不多，但一定是根本性的决策。
他们需要的是正确的战略，而不是令人眼花缭乱的战术。
**** 个人见解和决策的关系
决策的过程往往不是从搜集事实开始，而是先从其本人的见解开始的。
所谓见解，乃是“尚待证实的假设”；见解不能获得证实，就毫无价值可言。
但要确定什么才是事实，必须先确定相关的标准，尤其是有关的衡量标准。

有效的决策，常来自多种不同且互相冲突的见解中产生，常来自多种旗鼓相当、优劣互见的方案中产生。

适当的衡量方法只有依靠“反馈”制度。
**** 反面意见的运用
第一，唯有反面意见，才能保护决策者不致沦为组织的俘虏。
突破的办法就在于引起争辩、掌握实据和经过深思熟虑的反面意见。

第二，反面意见本身，正是决策所需的“另一方案”。

第三，反面意见可以激发想象力。

最后，还得问一个问题：“我们是不是真的需要一项决策？”
有时候什么都不做也是一种决策。

做决策与不做决策应遵循的原则：
- 如果利益远大于成本及风险，就该行动；
- 行动或不行动，切忌只做一半或折中。
** DONE 《Chris Richardson 谈微服务软件架构设计》笔记 :microservices:
CLOSED: [2016-12-10 Sat 16:47]
:PROPERTIES:
:EXPORT_FILE_NAME: notes-on-microservice-architecture
:END:
读完《Chris Richardson 谈微服务软件架构设计》后在此对一些重要观点进行记录。

<!--more-->

*** 微服务架构的优势与不足
*优势：*
1. 通过分解巨大单体应用为多个服务方法解决了复杂性问题。在功能不变的情况下，应用被分解为多个可管理的分支或服务。
   由此，单个服务很容易开发，理解和维护。
2. 这种架构使得每个服务都可以由专门开发团队来开发。开发者可以自由选择开发技术，提供 API 服务。
3. 微服务架构模式使得每个微服务独立部署，开发者不再需要协调其他服务部署对本服务的影响。
4. 微服务架构模式使得每个服务独立扩展。

*不足：*
1. 微服务强调了服务大小。
   尽管小服务更乐于被采用，但是不要忘了微服务只是结果，而不是最终目的。
   微服务的目的是有效的拆分应用，实现敏捷开发和部署。
2. 微服务应用是分布式系统，由此会带来固有的复杂性。开发者需要在 RPC 或者消息传递之间选择并完成进程间通讯机制。
3. 分区的数据库架构。
4. 测试基于微服务架构的应用是复杂的任务。
5. 微服务架构模式应用的改变将会波及多个服务，需要考虑相关改变对不同服务的影响。
6. 部署微服务很复杂。还需要完成一个服务发现机制，以用来发现与它通讯服务的地址。
*** 使用 API 网关构建微服务
[[/notes-on-microservice-architecture/api-gateway.jpg]]
**** API 网关的优缺点
最大的优点是封装了应用程序的内部结构。
简化了客户端代码。

缺点是增加了一个必须开发、部署和维护的高可用组件。
另外，API 网关成为了开发瓶颈。
更新网关的过程要尽可能简单，否则不得不排队等待。
**** 实现 API 网关
- 性能和可扩展性
- 使用响应式编程模型
- 服务调用
- 服务发现
- 处理局部失败
*** 微服务架构中的进程间通信
**** 交互模式
| Type         | One-to-Many            | One-to-One             |
|--------------+------------------------+------------------------|
| Synchronous  | -                      | Request/response       |
| Asynchronous | Publish/subscribe      | Notification           |
|              | Request/async response | Publish/async response |
**** 处理局部失败
- 网络超时
- 限制请求次数
- 断路器模式（Circuit Breaker Pattern）：记录成功和失败的请求数量。
  如果失败率超过阀值则触发一个失效期。
- 提供回滚
**** 基于消息的异步通信
*优点：*
- 解耦客户端和服务端
- 消息缓冲：使用消息队列。
- 客户端-服务端的灵活交互：消息机制支持所有交互模式。
- 清晰的进程间通信

*缺点：*
- 额外的操作复杂性：消息系统需要单独安装、配置和部署。
  消息代理必须高可用。
- 实现基于请求／响应交互模式的复杂性。
*** 服务发现的可行方案以及实践案例
**** 客户端发现模式
[[/notes-on-microservice-architecture/client-discovery-mode.jpg]]

客户端从服务注册服务中查询，其中是所有可用服务实例的库。
客户端使用负载均衡算法从多个服务实例中选择出一个，然后发出请求。

这一模式相对直接，除了服务注册外其他部分无需变动。
由于客户端知晓可用的服务实例，能针对特定应用实现智能负载均衡，比如哈希一致性。

一大缺点是客户端与服务注册绑定，要针对服务端用到的每个编程语言和框架实现客户端的服务发现逻辑。
**** 服务端发现模式
[[/notes-on-microservice-architecture/server-discovery-mode.jpg]]

客户端通过负载均衡器向某个服务提出请求，负载均衡器查询服务注册表，并将请求转发到可用的服务实例。
如同客户端发现，服务实例在服务注册表中注册或注销。

最大优点是客户端无需关注发现的细节，只需要简单的向负载均衡器发送请求，减少了编程语言框架需要完成的发现逻辑。
缺点是除非负载均衡器由部署环境提供，否则会成为一个需要配置和管理的高可用系统组件。
**** 服务注册的方式
1. 自注册方式

   服务实例负责在服务注册表中注册和注销。
   另外，服务实例也要发送心跳来保证注册信息不会过时。

   优点是简单，无需其他系统组件。
   缺点是把服务实例和服务注册耦合，必须在每个编程语言和框架内实现注册代码。
2. 第三方注册模式

   由服务注册器处理会通过查询部署环境或订阅事件的方式来跟踪运行实例的更改。

   优点是服务与服务注册解耦。
   缺点是要配置和管理一个高可用的系统组件。
*** 事件驱动的数据管理
**** 事件驱动的架构
当有显著事件发生时某个微服务会发布事件，其他微服务订阅这些事件。
当某一微服务接收到事件就可以更新自己的业务实体，实现更多事件被发布。

优点是使得事务跨多个服务并提供最终一致性，也可以让应用维护物化视图。
缺点是编程模型比 ACID 事务复杂。
为了从应用级别的失效中恢复，还需要完成补偿性事务。
要处理临时事务造成的数据不一致。
**** 实现原子化
例如插入一行数据然后发布事件。
确保原子化的标准做法是使用包含数据库和消息代理的分布式事务。
***** 使用本地事务发布事件
[[/notes-on-microservice-architecture/local-transaction-publisher.jpg]]

实现原子化的方法是使用多步骤进程来发布事件，该进程只包含本地事务。

用一个事件表来充当消息队列。
应用启动一个本地数据库事务，更新业务实体的状态，在事件表中插入一个事件，并提交该事务。
独立的应用线程或进程查询事件表，将事件发到消息代理，然后用本地事务标注事件并发布。

优点是保证每个更新都有对应的事件发布，并且无需依赖 2PC（两步提交）。
发布业务级别的事件，消除来推断事件的需要。
缺点是开发者必须牢记发布事件。
对 NoSQL 数据库应用是个挑战，NoSQL 本身交易和查询能力有限。
***** 挖掘数据库事务日志
应用更新数据库，数据库的事务日志记录变更。
事务日志挖掘线程或进程读取这些日志，并发布到消息代理。

优点是无需 2PC，日志发布与应用业务分离，简化应用。
缺点是事务日志的格式与每个数据库对应。
很难逆向工程业务事件。
***** 使用事件源
[[/notes-on-microservice-architecture/event-source.jpg]]

分别存储业务实体和业务状态。

优点是解决了事件驱动的微服务架构的一个关键问题，能够只要状态改变就可靠的发布事件。
解决了数据一致性问题。
业务逻辑由松耦合的、事件交换的业务实体构成。
*** 选择微服务部署策略
**** 单主机多服务实例模式
在一台物理或虚拟主机上运行多个服务实例。

*优点：*
- 资源利用率相对高效，多服务实例共享服务器及操作系统。
- 部署服务实例更快，只需将服务复制到主机并启动。
- 开销不多，启动服务通常很快。

*缺点：*
- 除非每个服务实例是一个单独的进程，否则会甚少或者没有隔离。不能限制每个实例使用的资源，很可能一个异常的服务实例会消耗主机所有的内存和 CPU。
- 所有实例可能共享同一个 JVM 堆，出现异常的服务实例能够轻易中断运行在同一进程的其他服务。
- 部署服务的运维团队需要了解部署的具体细节，增加率出错的风险。
**** 单主机单服务实例模式
***** 单虚拟机单服务实例模式
*优点：*
- 每个服务实例完全隔离运行，每个实例都有固定的 CPU 和内存。
- 能充分利用成熟的云基础设施。
- 封装了服务的实施技术。一旦服务打包成虚拟机就变成了黑盒，虚拟机的管理 API 成为部署该服务的 API。

*缺点：*
- 资源利用率低。有操作系统的开销。公有 IaaS 部署成本会因利用率低而增高。
- 部署服务的新版本通常很缓慢。
- 用户或组织中的其他人要负责大量无差别的沉重工作。
***** 单容器单服务实例模式
容器技术更为轻量，容器镜像构建速度更快。

缺点是管理容器镜像是一项无差别的繁重工作。
除非使用 Google Container Engine 或 Amazon EC2 容器服务。
***** 无服务部署
AWS Lambda 不适合用来部署长期运行的服务。
服务必须保持无状态。
必须用某一种支持的语言完成。
*** 使用微服务重构单体应用
Martin Fowler 所言，“大规模重写唯一能够保证的只有大规模！”

应当采取逐步重构单体应用的策略。
逐步构建一个由微服务构成的应用，与单体应用并行运行；
随着时间推移，原先由单体应用实现的功能不断收缩，最后或者完全消失，或者转变成微服务。

*策略：*
1. 停止挖坑：停止单体应用继续变大，应该把部分新代码开发成独立的微服务。
   新服务和旧服务直接有一层胶水代码，也被称作防崩溃层（anti-corruption layer）。
2. 拆分前端和后端：一个应用包含表示层，另一个包含业务和数据访问逻辑。
   通过远程调用。
3. 提取微服务：提取后单体应用不断收缩。
   - 为需要转化为微服务的模块设置优先级：可以根据获益程度、资源需求等。
   - 如何提取模块
     1. 定义模块和单体应用间的粒度接口
     2. 单体应用和微服务通过 API 通信

[[/notes-on-microservice-architecture/refactor-monolithic.jpg]]
* Blog :@blog:
** DONE 从 Jekyll 到 Hexo :blog:
CLOSED: [2018-03-02 Fri 00:20]
:PROPERTIES:
:EXPORT_FILE_NAME: migration-from-jekyll-to-hexo
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :toc false
:END:
我之前一个版本的博客也是托管在 GitHub 的静态博客，使用的是[[https://www.jekyll.com.cn/][Jekyll]]。
但是它提供的主题不是很符合我的口味，所以就去网上找了许多模板，最终使用了 Hux 的模板（[[http://huangxuan.me/][主页]]|[[https://github.com/Huxpro/huxpro.github.io][项目]]）。
虽然样式挺美观且简洁，但是可扩展性不强，更新起来麻烦。
如果要使用的话需要自己改很多文件。
于是最终放弃了 Jekyll 转到了 Hexo 阵营。

Hexo 是基于 Node.js 的博客框架，在 Windows 下只需要安装 Node.js 就可以写博客了，而不像 Jekyll 需要安装 Ruby 和其他依赖，另外 Ruby 对 Windows 也不友好。
Hexo 的开源贡献者有一大部分是国人，所以有中文文档（文档写的有点简略啊）。
最主要的是[[http://theme-next.iissnan.com/][Next 主题]]好看，容易配置和更新。
** DONE 从 Hexo 到 Hugo :blog:
CLOSED: [2020-04-10 Fri 18:12]
:PROPERTIES:
:EXPORT_FILE_NAME: migration-from-hexo-to-hugo
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :toc false
:END:
最近又开始折腾博客了，大概拖了有一个月了才开始记录迁移博客的感受。
简言之，让我从 Hexo 迁移到 Hugo 最大的原因是 Emacs Org mode 下的 Hugo 插件。

<!--more-->

一切的开始要从我入坑 Doom Emacs 说起。
以前我一直使用的是 Spacemacs，我非常感谢开发者做的贡献，让我使用到了那么易用的 Emacs 编辑器。
但是 Spacemacs 的速度有点慢，定制化的时候觉得有些杂乱，不是很方便，还有些卡。
还有 Spacemacs 的版本更新的有点慢，Issue 也似乎堆积的有点多。
加之最近放假闲下来了一段时间，所以又开始折腾乱七八遭的东西。

然后我就看到了 Doom Emacs。
有很多人推荐它，另外更新频率也很高，就开始用它了。
目前使用了已经有一段时间了，真的很不错。

在这之后，我就用 Doom Emacs 折腾博客了，想整一套 Org mode 写博客的工作流。
浏览网页的时候无意间看到了用 Org mode Hugo 来生成博客。
这种方式的优点是，写博客深度整合 Org mode 的特性，从内容编写到网页生成都很流畅。
所有的博客可以使用一个 Org 文件保存，方便管理和回顾。
此外，Hugo 生成博客的速度真的比 Hexo 快好多。

总之，一个能让我在 Emacs 里面完成所有博客相关活动的平台真的很舒服。
